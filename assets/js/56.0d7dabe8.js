(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{443:function(e,a,t){"use strict";t.r(a);var s=t(46),n=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"特性1-variadic-templates-可变参数模板"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性1-variadic-templates-可变参数模板"}},[e._v("#")]),e._v(" 特性1：Variadic Templates 可变参数模板")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// ...参数个数可变，参数类型可变\n// sizeof...(args) 返回函数参数的数目\n// sizeof...(Types) 返回类型参数的数目\n// 可以很方便完成recursive function call\nvoid print(){}//个数为0时调用，相当于终止点\ntemplate<typename T, typename... Types>\nvoid print(const T& firstArg, const Types&... args)\n{\n    cout << firstArg << endl;\n    print(args...);\n}\n//与上面的函数可以并存，上面的是特化版本\ntemplate<typename... Types>\nvoid print(const Types&... args){}\n\n// 可以完成recursive inheritance\ntemplate<typename... Valuse> class tuple;\ntemplate<> class tuple<>{};\ntemplate<typename Head, typename... Tail>\nclass tuple<Head, Tail...>:private tuple<Tail...>{};\n\n// recursive composition\ntemplate<typename... Values> class tup;\ntemplate<> class tup<>{};\ntemplate<typename Head, typename... Tail>\nclass tup<Head, Tail...>\n{\n  typedef tup<Tail...> composited;\nprotected:\n  composited m_tail;\n  Head m_head;\npublic:\n\n}\n\n")])])]),t("h2",{attrs:{id:"特性2-空指针nullptr"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性2-空指针nullptr"}},[e._v("#")]),e._v(" 特性2：空指针nullptr")]),e._v(" "),t("p",[e._v("对指针初始化为空时，赋值为nullptr")]),e._v(" "),t("h2",{attrs:{id:"特性3-initializer-list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性3-initializer-list"}},[e._v("#")]),e._v(" 特性3：initializer list")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('int j{};//0\nint* p{};//nullptr\nint i{5.3};//warning:initialer list not allow narrowing\nvoid print(std::initializer_list<int> vals)\n{\n  for(auto p=vals.begin(); p!=vals.end(); ++p){\n    std::cout<<*p<<"\\n";\n  }\n}\n')])])]),t("h2",{attrs:{id:"特性4-explict"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性4-explict"}},[e._v("#")]),e._v(" 特性4：explict")]),e._v(" "),t("p",[e._v("explicit 用于转换convert的时候，明确的，不能转换")]),e._v(" "),t("h2",{attrs:{id:"特性5-default-delete"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性5-default-delete"}},[e._v("#")]),e._v(" 特性5：=default, =delete")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Foo(const Foo&) copy ctor cannot be overload\n//当自定义了拷贝构造函数，默认的拷贝构造函数无法=default或=delete\nFoo& operator(const Foo&) operator= cannot be overload(copy assign)\n//当自定义了拷贝赋值函数，默认的拷贝赋值函数无法=default或=delete\n")])])]),t("h2",{attrs:{id:"特性6-alias-template-模板的别名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性6-alias-template-模板的别名"}},[e._v("#")]),e._v(" 特性6：alias template（模板的别名）")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("template<typename T>\nusing Vec = std::vector<T, MyAlloc<T>>;\n\nVec<int> is equivalent to std::vector<int, MyAlloc<int>>\n")])])]),t("p",[e._v("template template parameter")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("template<typename name, template<class> class Container>\nclass XCls{};\n//Error: vector need two template parameter\nXCls<MyString, vector> cl;\n//以下版本是对的\ntemplate<typename T>\nusing Vec = vector<T, alloctor<T>>;\ntemplate<typename name, template<class> class Container>\nclass XCls{};\nXCls<MyString, Vec> cl;\n")])])]),t("h2",{attrs:{id:"特性7-type-alias"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性7-type-alias"}},[e._v("#")]),e._v(" 特性7：type alias")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//typedef void(*func)(int, int);\nusing func = void(*)(int, int);\n")])])]),t("h2",{attrs:{id:"特性8-noexcept"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性8-noexcept"}},[e._v("#")]),e._v(" 特性8：noexcept")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//用来指明某个函数无法——或不打算——抛出异常。\nvoid foo() noexcept;\n//若有异常未在foo()内被处理，亦即如果foo()抛出异常，程序会被终止。\n")])])]),t("h2",{attrs:{id:"特性9-override-final"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性9-override-final"}},[e._v("#")]),e._v(" 特性9：override final")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("virtual void func(int);//A\nvirtual void func(int) override;//B:A 告诉编译器B重写了A中的func函数\n\nclass A final{};//A不允许被继承\nclass A{\n  vitural void f() final;//f函数不允许被重写\n}\n")])])]),t("h2",{attrs:{id:"特性10-decltype"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性10-decltype"}},[e._v("#")]),e._v(" 特性10：decltype")]),e._v(" "),t("p",[e._v("let the compiler find out the type of an expression")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("map<string,float> coll;\ndecltype(coll)::value_type elem;\n")])])]),t("p",[e._v("应用1：声明返回类型")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("template<typename T1, typename T2>\ndecltype(x+y) add(T1 x, T2 y);//编译不通过\n\ntemplate<typename T1, typename T2>\nauto add(T1 x, T2 y) -> decltype(x+y);//this uses the same syntax as for lambdas to declare return types.\n")])])]),t("p",[e._v("应用2：超编程 metaprogramming")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("typedef typename decltype(obj)::iterator iType;\n")])])]),t("p",[e._v("应用3：传递一个lambda类型 used to pass the type of a lambda")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("auto cmp = [](const Person& p1, const Person& p2){\n  return p1.lastname()<p2.lastname() || \n    (p1.lastname()==p2.lastname() && p1.firstname()<p2.firstname());\n};\nstd::set<Person,decltype(cmp)> coll(cmp);\n")])])]),t("h2",{attrs:{id:"特性11-lambda"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性11-lambda"}},[e._v("#")]),e._v(" 特性11：Lambda")]),e._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("[]() mutable -> retType{};\n[=] pass by value\n[&] pass by reference\nmutable, operator()被定义为non-const成员函数\n")])])]),t("h2",{attrs:{id:"特性12-revalue-references"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性12-revalue-references"}},[e._v("#")]),e._v(" 特性12：Revalue references")]),e._v(" "),t("p",[e._v("solve the problem of unneccessary copying and enable perfect forwarding\nwhen the right-hand side of an assignment is an rvalue, then the left-hand side object can steal resources from the right-hand side object rather than performing a separate allocation\nLvalue:可以出现在operate=左侧\nRvalue:只能出现在operate=右侧")]),e._v(" "),t("h2",{attrs:{id:"特性13-hashtable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特性13-hashtable"}},[e._v("#")]),e._v(" 特性13：hashtable")]),e._v(" "),t("p",[e._v("当元素个数大于bucket vector大小时，会rehashing，增长到原来bucket vector的二倍")])])}),[],!1,null,null,null);a.default=n.exports}}]);