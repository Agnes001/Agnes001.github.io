(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{480:function(t,a,n){"use strict";n.r(a);var s=n(46),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"_1-引用的概念"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-引用的概念"}},[t._v("#")]),t._v(" 1 引用的概念")]),t._v(" "),n("ol",{attrs:{start:"0"}},[n("li",[t._v("引用可以看作是一个已定义变量的别名。")]),t._v(" "),n("li",[t._v("引用没有定义, 是一种关系型声明。声明它和原有某一变量(实体)的关系。故而类型与原类型保持一致, 且不分配内存,与被引用的变量有相同的地址。")]),t._v(" "),n("li",[t._v("声明的时候必须初始化, 一经声明, 不可变更。")]),t._v(" "),n("li",[t._v("可对引用, 再次引用。多次引用的结果, 是某一变量具有多个别名。")]),t._v(" "),n("li",[t._v("& 符号前有数据类型时, 是引用,其它皆为取地址.")]),t._v(" "),n("li",[t._v("普通引用在声明时必须用其它的变量进行初始化，引用作为函数参数声明时不进行初始化。")]),t._v(" "),n("li",[t._v("c++中引入引用后,可以用引用解决的问题。避免用指针来解决。")])]),t._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[t._v("//如果我们在去研究引用的时候，你可以将引用当做一个常指针去研究\n//当你在使用引用编程的时候，你就把引用理解为变量的别名就可以了。\n\n"),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("）引用在C++中的内部实现是一个常指针\n Type"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" name "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" Type* const name\n"),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("）C++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同。\n"),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("）从使用的角度，引用会让人误会其只是一个别名，没有自己的存储空间。这是C++为了实用性而做出的细节隐藏。\n")])])]),n("h2",{attrs:{id:"_2-引用作为函数的返回值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-引用作为函数的返回值"}},[t._v("#")]),t._v(" 2 引用作为函数的返回值")]),t._v(" "),n("h3",{attrs:{id:"_2-1-当函数返回值为引用时-若返回栈变量-不能成为其它引用的初始值-不能作为左值使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-当函数返回值为引用时-若返回栈变量-不能成为其它引用的初始值-不能作为左值使用"}},[t._v("#")]),t._v(" 2.1 当函数返回值为引用时,若返回栈变量: 不能成为其它引用的初始值（不能作为左值使用）")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('include\t<iostream>\t\nusing namespace\tstd;\t\nint\tgetA1()\t\n{\t\n\tint\ta;\t\n\ta\t=\t10;\t\n\treturn\ta;\t\n}\t\nint& getA2()\t\n{\t\n\tint\ta;\t\n\ta\t=\t10;\t\n\treturn\ta;\t\n}\t\nint\tmain(void)\t\n{\t\n\tint\ta1\t=\t0;\t\n\tint\ta2\t=\t0;\t\n\t//值拷⻉\n\ta1\t=\tgetA1();\t\n\t//将⼀个引⽤赋给⼀个变量，会有拷⻉动作\n\t//理解： 编译器类似做了如下隐藏操作，a2\t= *(getA2())\n\ta2\t=\tgetA2();\t\n\t//将⼀个引⽤赋给另⼀个引⽤作为初始值，由于是栈的引⽤，内存⾮法\n\tint\t&a3\t= getA2();\t\n\tcout\t<<"a1\t=\t"\t<<a1<<endl;\t\n\tcout\t<<"a2\t=\t"\t<<a2<<endl;\t\n\tcout\t<<"a3\t=\t"\t<<a3<<endl;\t\n\treturn 0;\t\n}\n')])])]),n("h3",{attrs:{id:"_3-2-当函数返回值为引用时-若返回静态变量或全局变量-可以成为其他引用的初始值-可作为右值使用-也可作为左值使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-当函数返回值为引用时-若返回静态变量或全局变量-可以成为其他引用的初始值-可作为右值使用-也可作为左值使用"}},[t._v("#")]),t._v(" 3.2  当函数返回值为引用时, 若返回静态变量或全局变量, 可以成为其他引用的初始值（可作为右值使用，也可作为左值使用）")]),t._v(" "),n("div",{staticClass:"language-C++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('#include\t<iostream>\nusing namespace\tstd;\t\nint\tgetA1()\t\n{\t\n\tstatic int\ta;\t\n\ta\t=\t10;\t\n\treturn\ta;\t\n}\t\nint&\tgetA2()\t\n{\t\n\tstatic int\ta;\t\n\ta\t=\t10;\t\n\treturn\ta;\t\n}\t\nint\tmain(void)\t\n{\t\n\tint\ta1\t=\t0;\t\n\tint\ta2\t=\t0;\t\n\t//值拷⻉\n\ta1\t=\tgetA1();\t\n\t//将⼀个引⽤赋给⼀个变量，会有拷⻉动作\n\t//理解： 编译器类似做了如下隐藏操作，a2 = *(getA2())\n\ta2\t=\tgetA2();\t\n\t//将⼀个引⽤赋给另⼀个引⽤作为初始值，由于是静态区域，内存合法\n\tint\t&a3\t=\tgetA2();\t\n\tcout\t<<"a1\t=\t"\t<<a1<<endl;\t\n\tcout\t<<"a2\t=\t"\t<<a2<<endl;\t\n\tcout\t<<"a3\t=\t"\t<<a3<<endl;\t\n\treturn 0;\t\n}\n')])])]),n("h2",{attrs:{id:"_3-指针引用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-指针引用"}},[t._v("#")]),t._v(" 3 指针引用")]),t._v(" "),n("div",{staticClass:"language-C++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('int get_mem2(struct teacher* &tp)\n{\n\ttp = (struct teacher*)malloc(sizeof(struct teacher));\n\tif (tp == NULL) {\n\t\treturn -1;\n\t}\n\ttp->id = 300;\n\tstrcpy(tp->name, "wang5");\n\n\treturn 0;\n}\n')])])]),n("h2",{attrs:{id:"_4-const引用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-const引用"}},[t._v("#")]),t._v(" 4 const引用")]),t._v(" "),n("blockquote",[n("p",[t._v("const对象的引用必须是const的,将普通引用绑定到const对象是不合法的。这个原因比较简单，既然对象是const的,表示不能被修改,引用当然也不能修改,必须使用const引用。如下写法是不合法的,编译不过。")])]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const int a=1; \nint &b=a;\n")])])]),n("blockquote",[n("p",[t._v("const引用可使用相关类型的对象(常量,非同类型的变量或表达式)初始化。这个是const引用与普通引用最大的区别。")])]),t._v(" "),n("div",{staticClass:"language-C++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const int &a=2; //是合法的。\ndouble x=3.14; \nconst int &b=x; //也是合法\n\n//常引⽤\nint\tx = 20;\t\nconst int &y = x;\t//常引⽤是限制变量通过y去修改x了\n//y\t= 21;\t\t\t//error\n")])])]),n("h2",{attrs:{id:"_5-右值引用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-右值引用"}},[t._v("#")]),t._v(" 5 右值引用")]),t._v(" "),n("p",[t._v("以上所述的引用皆为左值引用，左值引用即对左值进行绑定。相应的，右值引用是对右值的绑定。")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("int&& i = 0;\n")])])]),n("p",[t._v("区分左值和右值：看能不能对表达式取地址，如果能，则为左值，否则为右值。\n对右值的引用就是右值引用，而且右值是匿名变量。")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("T&& k = getVar();//getVar()产生的临时变量不会被销毁，而是会被“续命”，它的生命周期将会通过右值引用得以延续，和变量k的声明周期一样长。\n")])])]),n("p",[t._v("禁止返回值优化，添加参数 -fno-elide-constructors")])])}),[],!1,null,null,null);a.default=e.exports}}]);