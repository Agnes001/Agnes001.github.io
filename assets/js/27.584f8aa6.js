(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{486:function(e,t,a){"use strict";a.r(t);var n=a(46),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"thread"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#thread"}},[e._v("#")]),e._v(" thread")]),e._v(" "),a("p",[e._v("头文件内容")]),e._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("namespace std\n{\n  class thread;\n\n  namespace this_thread\n  {\n    thread::id get_id() noexcept;\n\n    void yield() noexcept;//调用线程不需要立即运行。一般使用小循环来避免消耗过多CPU时间。\n\n    template<typename Rep,typename Period>\n    void sleep_for(std::chrono::duration<Rep,Period> sleep_duration);\n\n    template<typename Clock,typename Duration>\n    void sleep_until(std::chrono::time_point<Clock,Duration> wake_time);\n  }\n}\n")])])]),a("h3",{attrs:{id:"std-thread类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#std-thread类"}},[e._v("#")]),e._v(" std::thread类")]),e._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("namespace std {\n  class thread {\n  public:\n    // 类型\n    class id;\n    using native_handle_type = /* 由实现定义 */;\n \n    // 构造/复制/销毁\n    thread() noexcept;\n    template<class F, class... Args> \n    explicit thread(F&& f, Args&&... args);\n    ~thread();\n    thread(const thread&) = delete;\n    thread(thread&&) noexcept;\n    thread& operator=(const thread&) = delete;\n    thread& operator=(thread&&) noexcept;\n \n    // 成员\n    void swap(thread&) noexcept;\n    bool joinable() const noexcept;\n    void join();//等待线程执行完成\n    void detach();//容许从线程句柄独立开来\n    id get_id() const noexcept;\n    native_handle_type native_handle();\n \n    // 静态成员\n    static unsigned int hardware_concurrency() noexcept;//返回支持的并发线程数\n  };\n}\n")])])]),a("h3",{attrs:{id:"std-this-thread命名空间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#std-this-thread命名空间"}},[e._v("#")]),e._v(" std::this_thread命名空间")]),e._v(" "),a("h2",{attrs:{id:"线程对象状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程对象状态"}},[e._v("#")]),e._v(" 线程对象状态")]),e._v(" "),a("p",[e._v("线程对象通过默认构造函数构造后状态为nonjoinable；线程对象通过有参构造函数创建后状态为joinable。joinable状态的线程对象被调用join()或者detach()会变成nonjoinable状态。")]),e._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class RAIIThread: public std::thread {\n...\n  ~RAIIThread() {\n    if (t.joinable()) std.terminate();\n  }\nprivate:\n  std::thread t;\n};\n")])])]),a("p",[e._v("线程对象析构时，会判断线程的状态。如果线程处于joinable状态时，会调用terminate()函数直接令程序退出，异常结束进程。也就是说，创建一个可运行(创建时传入线程函数)的线程对象后，必须对该线程对象进行处理，要么调用join()，要么调用detach()，否则线程对象析构时程序将直接退出。")]),e._v(" "),a("p",[e._v("以下内容引用自[https://blog.csdn.net/qq_28388835/article/details/81173317]")]),e._v(" "),a("ul",[a("li",[e._v("detach调用之后，目标线程就成为了守护线程，驻留后台运行，与之关联的std::thread对象失去对目标线程的关联，无法再通过std::thread对象取得该线程的控制权。当线程主函数执行完之后，线程就结束了，运行时库负责清理与该线程相关的资源。当一个thread对象到达生命期终点而关联线程还没有结束时，则thread对象取消与线程之间的关联，目标线程线程则变为分离线程继续运行。")]),e._v(" "),a("li",[e._v("当调用join函数时，调用线程阻塞等待目标线程终止，然后回收目标线程的资源。")])]),e._v(" "),a("p",[e._v("线程状态：")]),e._v(" "),a("p",[e._v("在一个线程的生存期内，可以在多种状态之间转换，不同的操作系统可以实现不同的线程模型，定义许多不同的线程状态，每个状态还可以包含多个子状态，但大体来说，如下几种状态是通用的：")]),e._v(" "),a("p",[e._v("1）就绪：参与调度，等待被执行，一旦被调度选中，立即开始执行")]),e._v(" "),a("p",[e._v("2）运行：占用CPU，正在运行中")]),e._v(" "),a("p",[e._v("3）休眠：暂不参与调度，等待特定事件发生")]),e._v(" "),a("p",[e._v("4）中止：已经运行完毕，等待回收线程资源")]),e._v(" "),a("p",[e._v("线程环境：")]),e._v(" "),a("p",[e._v("线程存在于进程之中，进程内所有全局资源对于内部每个线程都是可见的。")]),e._v(" "),a("p",[e._v("进程内典型全局资源如下：")]),e._v(" "),a("p",[e._v("1）代码区：这意味着当前进程空间内所有的可见的函数代码，对于每个线程来说，也是可见的")]),e._v(" "),a("p",[e._v("2）静态存储区：全局变量，静态空间")]),e._v(" "),a("p",[e._v("3）动态存储区：堆空间")]),e._v(" "),a("p",[e._v("线程内典型的局部资源：")]),e._v(" "),a("p",[e._v("1）本地栈空间：存放本线程的函数调用栈，函数内部的局部变量等")]),e._v(" "),a("p",[e._v("2）部分寄存器变量：线程下一步要执行代码的指针偏移量")]),e._v(" "),a("p",[e._v("一个进程发起后，会首先生成一个缺省的线程，通常称这个线程为主线程，C/C++程序中，主线程就是通过main函数进入的线程，由主线程衍生的线程成为从线程，从线程也可以有自己的入口函数，相当于主线程的main函数，这个函数由用户指定。通过thread构造函数中传入函数指针实现，在指定线程入口函数时，也可以指定入口函数的参数。就像main函数有固定的格式要求一样，线程的入口函数也可以有固定的格式要求，参数通常都是void"),a("em",[e._v("类型，返回类型根据协议的不同也不同，pthread中是void")]),e._v("，winapi中是unsigned int，而且都是全局函数。")]),e._v(" "),a("p",[e._v("最常见的线程模型中，除主线程较为特殊之外，其他线程一旦被创建，相互之间就是对等关系，不存在隐含的层次关系。每个进程可创建的最大线程数由具体实现决定。")]),e._v(" "),a("p",[e._v("无论在windows中还是Posix中，主线程和子线程的默认关系是：无论子线程执行完毕与否，一旦主线程执行完毕退出，所有子线程执行都会终止。这时整个进程结束或僵死，部分线程保持一种终止执行但还未销毁的状态，而进程必须在其所有线程销毁后销毁，这时进程处于僵死状态。线程函数执行完毕退出，或以其他非常方式终止，线程进入终止态，但是为线程分配的系统资源不一定释放，可能在系统重启之前，一直都不能释放，终止态的线程，仍旧作为一个线程实体存在于操作系统中，什么时候销毁，取决于线程属性。在这种情况下，主线程和子线程通常定义以下两种关系：")]),e._v(" "),a("p",[e._v("1、可会合（joinable）：这种关系下，主线程需要明确执行等待操作，在子线程结束后，主线程的等待操作执行完毕，子线程和主线程会合，这时主线程继续执行等待操作之后的下一步操作。主线程必须会合可会合的子线程。在主线程的线程函数内部调用子线程对象的wait函数实现，即使子线程能够在主线程之前执行完毕，进入终止态，也必须执行会合操作，否则，系统永远不会主动销毁线程，分配给该线程的系统资源也永远不会释放。")]),e._v(" "),a("p",[e._v("2、相分离（detached）：表示子线程无需和主线程会合，也就是相分离的。在线程数较多的情况下，有时让主线程逐个等待子线程结束，或者让主线程安排每个子线程结束的等待顺序，是很困难或不可能的，所以在并发子线程较多的情况下，这种方式也会经常使用。")]),e._v(" "),a("p",[e._v("在任何一个时间点上，线程是可结合（joinable）或者是可分离的（detached），一个可结合的线程能够被其他线程回收资源和杀死，在被其他线程回收之前，它的存储器资源如栈，是不释放的，相反，一个分离的线程是不能被其他线程回收或杀死的，它的存储器资源在它终止时由系统自动释放。")]),e._v(" "),a("p",[e._v("线程的分离状态决定一个线程以什么样的方式来终止自己，在默认的情况下，线程是非分离状态的，这种情况下，原有的线程等待创建的线程结束，只有当pthread_join函数返回时，创建的线程才算终止，释放自己占用的系统紫云啊，而分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。")])])}),[],!1,null,null,null);t.default=s.exports}}]);