(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{460:function(t,e,n){"use strict";n.r(e);var a=n(46),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("https://blog.csdn.net/fengbingchun/article/details/104115489?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1.pc_relevant_without_ctrlist&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-1.pc_relevant_without_ctrlist&utm_relevant_index=1")]),t._v(" "),n("h2",{attrs:{id:"future"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#future"}},[t._v("#")]),t._v(" future")]),t._v(" "),n("p",[n("future",[t._v("头文件提供处理异步结果(在其他线程上执行额结果)的工具。")])],1),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("namespace std\n{\n  enum class future_status {\n      ready, timeout, deferred };\n\n  enum class future_errc\n  {\n    broken_promise,\n    future_already_retrieved,\n    promise_already_satisfied,\n    no_state\n  };\n\n  class future_error;\n\n  const error_category& future_category();\n\n  error_code make_error_code(future_errc e);\n  error_condition make_error_condition(future_errc e);\n\n  template<typename ResultType>\n  class future;\n\n  template<typename ResultType>\n  class shared_future;\n\n  template<typename ResultType>\n  class promise;\n\n  template<typename FunctionSignature>\n  class packaged_task; // no definition provided\n\n  template<typename ResultType,typename ... Args>\n  class packaged_task<ResultType (Args...)>;\n\n  enum class launch {\n    async, deferred\n  };\n\n  template<typename FunctionType,typename ... Args>\n  future<result_of<FunctionType(Args...)>::type> async(FunctionType&& func,Args&& ... args);\n\n  template<typename FunctionType,typename ... Args>\n  future<result_of<FunctionType(Args...)>::type> async(std::launch policy,FunctionType&& func,Args&& ... args);\n}\n")])])]),n("h2",{attrs:{id:"std-future类型模板"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-future类型模板"}},[t._v("#")]),t._v(" std::future类型模板")]),t._v(" "),n("p",[t._v("future 封装的是一种访问异步操作的机制,我们看看官方文档怎么说说：")]),t._v(" "),n("blockquote",[n("p",[t._v("The class template std::future provides a mechanism to access the result of asynchronous operations: An asynchronous operation (created via std::async, std::packaged_task, or std::promise) can provide a std::future object to the creator of that asynchronous operation…")])]),t._v(" "),n("p",[t._v("当在一个线程（creator）中创建（通过std::async，std::packaged_task 或者 std::promise）了一个异步操作（asynchronous operations，通常就是创建了一个新的线程，执行操作）的时候，这个异步操作会返回一个 future 对象给当前的线程，供其访问异步操作的状态，结果等等。")]),t._v(" "),n("p",[t._v("future 某种意义上表示的是一个异步操作，通过其成员函数我们能够获悉异步操作处于什么样的情况。可以通过 get 来等待异步操作结束并返回结果，是一个阻塞过程。wait 等待异步操作结束结束，也是一个阻塞过程。wait_for 是超时等待返回结果，wait_util 类似。")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('std::future_status status;\ndo \n{\n    status = future.wait_for(std::chrono::seconds(1));\n    if (status == std::future_status::deferred) \n    {\n        std::cout << "deferred\\n";\n    } \n    else if (status == std::future_status::timeout) \n    {\n        std::cout << "timeout\\n";\n    } \n    else if (status == std::future_status::ready) \n    {\n        std::cout << "ready!\\n";\n    }\n} \nwhile (status != std::future_status::ready);\n')])])]),n("h2",{attrs:{id:"std-promise类型模板"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-promise类型模板"}},[t._v("#")]),t._v(" std::promise类型模板")]),t._v(" "),n("p",[t._v("std::promise类型模板提供设置异步结果的方法，这样其他线程就可以通过std::future实例来索引该结果。\n专业的 future 提供商")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('struct MyData\n{\n\tint value;\n\tfloat conf;\n};\n \nMyData data{0, 0.0f};\n \nint main()\n{\n\tstd::promise<MyData> dataPromise;\n\tstd::future<MyData> dataFuture = dataPromise.get_future();\n \n\tstd::thread producer(\n    [&] (std::promise<MyData> &data) -> void {\n      std::this_thread::sleep_for(std::chrono::seconds(1));\n      data.set_value({2, 1.0f});\n    }, \n    std::ref(dataPromise)\n  );\n \n\tstd::thread consumer(\n    [&] (std::future<MyData> &data) -> void {\n      auto a = data.valid();\n      std::cout << a << std::endl;\n      auto res = data.get();\n      std::cout << res.value << "\\t" << res.conf << std::endl;\n      auto b = data.valid();\n      std::cout << b << std::endl;\n    }, \n    std::ref(dataFuture)\n  );\n \n  producer.join();\n  consumer.join();\n \n  return 0;\n}\n')])])]),n("h2",{attrs:{id:"std-packaged-task类型模板"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-packaged-task类型模板"}},[t._v("#")]),t._v(" std::packaged_task类型模板")]),t._v(" "),n("p",[t._v("packaged_task 是对一个任务的抽象，我们可以给其传递一个函数来完成其构造。\nstd::packaged_task包装任何可调用目标(函数、lambda表达式、bind表达式、函数对象)以便它可以被异步调用。它的返回值或抛出的异常被存储于能通过std::future对象访问的共享状态中。简言之，将一个普通的可调用函数对象转换为异步执行的任务。")]),t._v(" "),n("p",[t._v("通过packaged_task包装后，可以通过thread启动或者仿函数形式启动，其执行结果返回值或所抛异常被存储于能通过 std::future 对象访问的共享状态中。")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('#include <iostream>           // std::cout\n#include <thread>             // std::thread\n#include <chrono>\n#include <future>\nusing namespace std;\n//普通函数\nint Add(int x, int y)\n{\n    return x + y;\n}\nvoid task_lambda()\n{\n    //包装可调用目标时lambda\n    packaged_task<int(int,int)> task([](int a, int b){ return a + b;});    \n    //仿函数形式，启动任务\n    task(2, 10);    \n    //获取共享状态中的值,直到ready才能返回结果或者异常\n    future<int> result = task.get_future();\n    cout << "task_lambda :" << result.get() << "\\n";\n}\nvoid task_thread()\n{\n    //包装普通函数\n    std::packaged_task<int (int,int)> task(Add);\n    future<int> result = task.get_future();\n    //启动任务，非异步\n    task(4,8);\n    cout << "task_thread :" << result.get() << "\\n";\n        \n    //重置共享状态\n    task.reset();\n    result = task.get_future();\n\n    //通过线程启动任务，异步启动\n    thread td(move(task), 2, 10);\n    td.join();\n    //获取执行结果\n    cout << "task_thread :" << result.get() << "\\n";\n}\n\nint main(int argc, char *argv[])\n{\n    task_lambda();\n    task_thread();\n    return 0;\n}\n')])])]),n("h2",{attrs:{id:"std-async函数模板"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-async函数模板"}},[t._v("#")]),t._v(" std::async函数模板")]),t._v(" "),n("p",[t._v("std::async 大概的工作过程：先将异步操作用 std::packaged_task 包装起来，然后将异步操作的结果放到 std::promise 中，这个过程就是创造未来的过程。外面再通过 future.get/wait 来获取这个未来的结果。可以说，std::async 帮我们将 std::future、std::promise 和 std::packaged_task 三者结合了起来。")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("template <class Fn, class... Args>\nfuture<typename result_of<Fn(Args...)>::type>\n  async (launch policy, Fn&& fn, Args&&... args);\n\n//该模板函数 async 异步地运行函数 fn 并返回最终将保存该函数调用结果的 std::future 中，其中policy策略有以下三种：\n// 异步启动的策略  \nenum class launch {  \n    // 异步启动，在调用std::async()时创建一个新的线程以异步调用函数，并返回future对象；\n    async = 0x1,\n    // 延迟启动，在调用std::async()时不创建线程，直到调用了future对象的get()或wait()方法时，才创建线程；                    \n    deferred = 0x2,  \n     // 自动，函数在某一时刻自动选择策略，这取决于系统和库的实现，通常是优化系统中当前并发的可用性           \n    any = async | deferred,      \n    sync = deferred  \n}; \n")])])]),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// launch::async vs launch::deferred\n#include <iostream>     // std::cout\n#include <future>       // std::async, std::future, std::launch\n#include <chrono>       // std::chrono::milliseconds\n#include <thread>       // std::this_thread::sleep_for\n\nvoid print_ten (char c, int ms) {\n  for (int i=0; i<10; ++i) {\n    std::this_thread::sleep_for (std::chrono::milliseconds(ms));\n    std::cout << c;\n  }\n}\n\nint main ()\n{\n  std::cout << \"with launch::async:\\n\";\n  std::future<void> foo = std::async (std::launch::async,print_ten,'*',100);\n  std::future<void> bar = std::async (std::launch::async,print_ten,'@',200);\n  // async \"get\" (wait for foo and bar to be ready):\n  foo.get();\n  bar.get();\n  std::cout << \"\\n\\n\";\n\n  std::cout << \"with launch::deferred:\\n\";\n  foo = std::async (std::launch::deferred,print_ten,'*',100);\n  bar = std::async (std::launch::deferred,print_ten,'@',200);\n  // deferred \"get\" (perform the actual calls):\n  foo.get();\n  bar.get();\n  std::cout << '\\n';\n\n  return 0;\n}\n")])])]),n("h2",{attrs:{id:"关系"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#关系"}},[t._v("#")]),t._v(" 关系")]),t._v(" "),n("p",[t._v("std::future是用于获取将来共享状态的运行结果或异常，相当于一个中间件，std::async 、std::promise、std::packaged_task都离不开它的帮助；")]),t._v(" "),n("p",[t._v("std::packaged_task用于包装可调用目标，以便异步执行任务；")]),t._v(" "),n("p",[t._v("std::promise用于设置共享状态的值，可以用于线程间交流，这个是比较特殊的。")]),t._v(" "),n("p",[t._v("std::async是最优雅地方式启动任务异步执行；在多数情况下，建议使用asyn开启异步任务，而不是使用packaged_task方式。")])])}),[],!1,null,null,null);e.default=s.exports}}]);