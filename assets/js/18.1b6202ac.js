(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{464:function(t,i,n){"use strict";n.r(i);var _=n(46),v=Object(_.a)({},(function(){var t=this,i=t.$createElement,n=t._self._c||i;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),n("p",[t._v("首先，需要分清楚初始化与赋值，初始化是创建变量时赋予一个初始值；赋值的是把对象的当前值擦除，而以一个新值来替代。")])]),t._v(" "),n("p",[t._v("初始值可以借助大括号'{ }'，等号 '=' ，圆括号 '( )' ：")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("int x(0);    // 初始值在圆括号内\n\nint y = 0;   // 初始值在等号后面\n\nint z{0};    // 初始值在大括号内\n")])])]),n("p",[t._v("使用拷贝初始化时，只能提供一个初始值。\n类内成员的初始化(类内初始值)，可以使用花括号和等号，但不能使用圆括号。\n初始元素值的列表，只能使用列表初始化。\n当用于内置类型的变量时，使用列表初始化且初始值存在丢失信息的风险，则编译器报错。")]),t._v(" "),n("h2",{attrs:{id:"_1-列表初始化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-列表初始化"}},[t._v("#")]),t._v(" 1 列表初始化")]),t._v(" "),n("h2",{attrs:{id:"_2-直接初始化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-直接初始化"}},[t._v("#")]),t._v(" 2 直接初始化")]),t._v(" "),n("p",[t._v("使用()的赋值方式，称之为直接初始化。")]),t._v(" "),n("h2",{attrs:{id:"_3-拷贝初始化"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-拷贝初始化"}},[t._v("#")]),t._v(" 3 拷贝初始化")]),t._v(" "),n("p",[t._v("如果使用等号(=)初始化一个变量，实际执行的是拷贝初始化，编译器把右侧的初始值拷贝到新创建的对象中去。")]),t._v(" "),n("p",[t._v("以下内容来自：https://zhuanlan.zhihu.com/p/268894227")]),t._v(" "),n("p",[t._v("C++11的对象初始化的语法选择是不堪和混乱的。总的来说，初始值可以借助大括号'{ }'，等号 '=' ，圆括号 '( )' ：")]),t._v(" "),n("p",[t._v("int x(0);    // 初始值在圆括号内")]),t._v(" "),n("p",[t._v("int y = 0;   // 初始值在等号后面")]),t._v(" "),n("p",[t._v("int z{0};    // 初始值在大括号内\n使用等号初始化经常会让C++初学者认为会进行一次赋值，但不是那样的，对于内置类型，例如int，初始化和赋值操作的差别是模糊的。但是对于用户定义的类，区分初始化和赋值操作是很重要的，因为这会导致不同的函数调用：")]),t._v(" "),n("p",[t._v("Widget w1;       // 调用默认构造函数")]),t._v(" "),n("p",[t._v("Widget w2 = w1;  // 不是赋值操作，调用拷贝构造函数")]),t._v(" "),n("p",[t._v("w1 = w2;         // 赋值操作，调用operator=函数\n因为初始化的语法很混乱，而且有些情况无法实现，所以C++11提出了统一初始化语法：一种至少在概念上可以用于表达任何值的语法。它的实现基于大括号，所以我称之为大括号初始化。")]),t._v(" "),n("p",[t._v("使用大括号可以更容易的初始化容器列表初始化：std::vector"),n("int",[t._v(" v{1, 3, 5};")])],1),t._v(" "),n("p",[t._v("大括号也可以用于类内成员的默认初始值，在C++11中，等号”=”也可以实现，但是圆括号 '( )' 则不可以：")]),t._v(" "),n("p",[t._v("class Widget {\n...\nprivate:\nint x{ 0 };   // x的默认初始值为0\nint y = 0;    // 同上\nint z( 0 );   // 报错\n}\n另一方面，不可拷贝对象(例如，std::atomic)可以用大括号和圆括号初始化，但不能用等号：")]),t._v(" "),n("p",[t._v("std::atomic"),n("int",[t._v(" ai1{ 0 };  // 可以")])],1),t._v(" "),n("p",[t._v("std::atomic"),n("int",[t._v(" ai2( 0 );  // 可以")])],1),t._v(" "),n("p",[t._v("std::atomic"),n("int",[t._v(" ai3 = 0;   // 报错\n注意：当大括号初始化用于内置类型的变量时，如果我们初始值存在丢失信息的风险，则编译器将报错：")])],1),t._v(" "),n("p",[t._v("doubel ld = 3.14;\nint a {ld};    // 报错，存在信息丢失风险\nint b (ld);    // 正确\n大括号初始化的另一个值得注意的特性是它会免疫C++中的最让人头痛的歧义。当开发者想要一个默认构造的对象时，程序会不经意地声明个函数而不是构造对象。")]),t._v(" "),n("p",[t._v("Widget w1(10);  // 调用Widget的带参构造函数\n但当你尝试用类似的语法调用无参构造时，你声明了个函数，而不是创建对象：")]),t._v(" "),n("p",[t._v("Widget w2();   // 最让人头痛的歧义，声明了一个名为w2，不接受任何参数，返回Widget类型的函数！\nWidget w2;     // 正确：w2是个默认初始化的对象\n使用大括号包含参数是无法声明为函数的，所以使用大括号默认构造对象不会出现这个问题：")]),t._v(" "),n("p",[t._v("Widget w2{};   // 无歧义\n我们讲了很多大括号初始化的内容，这种语法可以用于多种场景，还可以避免隐式范围窄化转换，又免疫C++的最让人头痛的歧义问题。一举多得，那么为什么这条款不起名为“用大括号初始化语法替代其他”呢?")]),t._v(" "),n("p",[t._v("大括号初始化的缺点是它有时会显现令人惊讶的的行为。这些行为的出现是因为与std::initializer_list混淆了。在构造函数中，只要形参不带有std::initializer_list，圆括号和大括号行为一致：")]),t._v(" "),n("p",[t._v("class Widget {\npublic:\nWidget(int i, bool b);\nWidget(int i, double d);\n...\n};")]),t._v(" "),n("p",[t._v("Widget w1(10, true);  // 调用第一个构造函数")]),t._v(" "),n("p",[t._v("Widget w2{10, true};  // 调用第一个构造函数")]),t._v(" "),n("p",[t._v("Widget w3(10, 5.0);   // 调用第二个构造函数")]),t._v(" "),n("p",[t._v("Widget w4{10, 5.0};   // 调用第二个构造函数\n但是，如果构造函数的形参带有std::initializer_list，调用构造函数时大括号初始化语法会强制使用带std::initializer_list参数的重载构造函数：")]),t._v(" "),n("p",[t._v("class Widget {\npublic:\nWidget(int i, bool b);\nWidget(int i, double d);\nWidget(std::initializer_list"),n("long",{attrs:{double:""}},[t._v(" il);\n...\n};\nWidget w1(10, true);   // 使用圆括号，调用第一个构造函数")])],1),t._v(" "),n("p",[t._v("Widget w2{10, true};   // 使用大括号，强制调用第三个构造函数，10和true被转换为long double")]),t._v(" "),n("p",[t._v("Widget w3(10, 5.0);    // 使用圆括号，调用第二个构造函数")]),t._v(" "),n("p",[t._v("Widget w4{10, 5.0};    // 使用大括号，强制调用第三个构造函数，10和5.0被转换为long double\n就算是正常的拷贝构造和赋值构造也可以被带有std::initializer_list的构造函数劫持：")]),t._v(" "),n("p",[t._v("class Widget {\npublic:\nWidget(int i, bool b);\nWidget(int i, double d);\nWidget(std::initializer_list"),n("long",{attrs:{double:""}},[t._v(" il);\noperator float() const;   // 支持隐式转换为float类型\n...\n};")])],1),t._v(" "),n("p",[t._v("Widget w5(w4);    // 使用圆括号，调用拷贝构造函数")]),t._v(" "),n("p",[t._v("Widget w6{w4};    // 使用大括号，调用第三个构造函数\n// 原因是先把w4转换为float，再把float转换为long dobule")]),t._v(" "),n("p",[t._v("Widget w7(std::move(m4));  // 使用圆括号，调用移动构造函数")]),t._v(" "),n("p",[t._v("Widget w8{std::move(m4)};  // 使用大括号，调用第三个构造函数，理由同w6\n编译器用带有std::initializer_list构造函数匹配大括号初始值的决心是如此的坚定，即使带有std::initializer_list的构造函数是无法调用的，编译器也会忽略另外两个构造函数(第二个还是参数精确匹配的)：")]),t._v(" "),n("p",[t._v("class Widget {\npublic:\nWidget(int i, bool b);\nWidget(int i, double d);\nWidget(std::initializer_list"),n("bool",[t._v(" il);  // long double 改为 bool\n...\n};")])],1),t._v(" "),n("p",[t._v("Widget w{10, 5.0};  // 报错，因为发生范围窄化转换\n// 编译器会忽略另外两个构造函数(第二个还是参数精确匹配的！)\n只有当大括号内的值无法转换为std::initializer_list元素的类型时，编译器才会使用正常的重载选择方法:")]),t._v(" "),n("p",[t._v("class Widget {\npublic:\nWidget(int i, bool b);\nWidget(int i, double d);\nWidget(std::initializer_list"),n("a",{attrs:{href:"std::string"}},[t._v("std::string")]),t._v(" il);  // bool 改为 std::string\n...\n};")]),t._v(" "),n("p",[t._v("Widget w1(10, true);  // 使用圆括号，调用第一个构造函数")]),t._v(" "),n("p",[t._v("Widget w2{10, true};  // 使用大括号，不过调用第一个构造函数，因为无法转换为string")]),t._v(" "),n("p",[t._v("Widget w3(10, 5.0);   // 使用圆括号，调用第二个构造函数")]),t._v(" "),n("p",[t._v("Widget w4{10, 5.0};   // 使用大括号， 不过调用第二个构造函数，因为无法转换为string\n不过这里有一个有趣的边缘情况。一个大括号内无参的构造函数，不仅可以表示默认构造，还可以表示带std::initializer_list的构造函数。你的空括号是表示哪一种情况呢？")]),t._v(" "),n("p",[t._v("正确答案是你将使用默认构造，一个空的大括号表示的是没有参数，而不是一个空的std::initializer_list：")]),t._v(" "),n("p",[t._v("class Widget {\npublic:\nWidget();\nWidget(std::initializer_list"),n("int",[t._v(" il);\n...\n};")])],1),t._v(" "),n("p",[t._v("Widget w1;     // 调用默认构造函数")]),t._v(" "),n("p",[t._v("Widget w2{};   // 调用默认构造函数\n如果你想要用一个空的std::initializer_list参数来调用带std::initializer_list构造函数，那么你需要把大括号作为参数，即把空的大括号放在圆括号内或者大括号内：")]),t._v(" "),n("p",[t._v("Widget w4({});   // 用了一个空的list来调用带std::initializer_list构造函数\n此时此刻，大括号初始化，std::initializer_list，构造函数重载之间的复杂关系在你的大脑中冒泡，你可能想要知道这些信息会在多大程度上关系到你的日常编程。可能比你想象中要多，因为std::vector就是一个被它们直接影响的类。std::vector中有一个可以指定容器的大小和容器内元素的初始值的不带std::initializer_list构造函数，但它也有一个可以指定容器中元素值的带std::initializer_list函数。")]),t._v(" "),n("p",[t._v("std::vector"),n("int",[t._v(" v1(10, 20);   // 使用不带std::initializer_list的构造函数\n// 创建10个元素的vector，每个元素的初始值为20")])],1),t._v(" "),n("p",[t._v("std::vector"),n("int",[t._v(" v2{10, 20};   // 使用带std::initializer_list的构造函数\n// 创建2个元素的vector，元素值为10和20")])],1)])}),[],!1,null,null,null);i.default=v.exports}}]);