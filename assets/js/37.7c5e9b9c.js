(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{469:function(t,a,e){"use strict";e.r(a);var s=e(46),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"_1-类与类的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-类与类的关系"}},[t._v("#")]),t._v(" 1 类与类的关系")]),t._v(" "),e("h3",{attrs:{id:"_1-1-继承-inheritance-表示-is-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-继承-inheritance-表示-is-a"}},[t._v("#")]),t._v(" 1.1 继承（inheritance） 表示 is-a")]),t._v(" "),e("p",[t._v("父类和派生类被称为继承。")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class _List_node_base{...}; // base class \n\nclass _Lisr_node: public _List_node_base {...} // derived class \n")])])]),e("h3",{attrs:{id:"_1-2-组合-composition-表示has-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-组合-composition-表示has-a"}},[t._v("#")]),t._v(" 1.2 组合 (composition) 表示has-a")]),t._v(" "),e("p",[t._v("类中包含另一个类的对象，所占空间累加在当前对象上")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("template <class T, class Sequence = deque<T>>\nclass queue {\n...\nprotected:\nSequence c; // 底层容器\npublic:\n// 以下完全利用 c 的操作函數完成\nbool empty() const { return c.empty(); }\nsize_type size() const { return c.size(); }\nreference front() { return c.front(); }\nreference back() { return c.back(); }\n// deque 是兩端可進出，queue 是末端進前端出（先進先出）\nvoid push(const value_type& x) { c.push_back(x); }\nvoid pop() { c.pop_front(); }\n};\n")])])]),e("p",[t._v("构造由内而外，析构由外而内：构造时先调用里边对象的构造函数，然后再调用当前类的构造函数，析构时正好相反。")]),t._v(" "),e("p",[t._v("非共有继承也是一种has-A的组合方式，非公有继承中，子类不能转化为父类，因为创建父类指针指向子类对象的时候，会调用子类构造函数，再调用父类构造函数，但此时父类构造函数的访问权限是非共有的，因此访问不到父类的构造函数，即无法用这种方式创建对象。主要在基类中没有普通成员属性的时候使用这种继承方式，可以减少内存占用。")]),t._v(" "),e("h3",{attrs:{id:"_1-3-委托-delegation-表示composition-by-reference"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-委托-delegation-表示composition-by-reference"}},[t._v("#")]),t._v(" 1.3 委托 (delegation) 表示composition by reference")]),t._v(" "),e("p",[t._v("类内含有另一个类的指针。")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class StringRep;\nclass String\n{\npublic:\n\t... // 一些公有接口\nprivate:\n\tStringRep* rep; //类内含有类的指针\n}\n\nclass StringRep{...};\n")])])]),e("p",[e("strong",[t._v("组合与委托的区别")])]),t._v(" "),e("ul",[e("li",[t._v("组合生命是一起出现的，有queue对象就有了deque对象。")]),t._v(" "),e("li",[t._v("而委托，类内含有指针，只有需要用到类指针的时候才会有指向的实现类，不同步。")])]),t._v(" "),e("h2",{attrs:{id:"_2-继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-继承"}},[t._v("#")]),t._v(" 2 继承")]),t._v(" "),e("p",[t._v("单继承：同时有多个父类\n多继承：只有一个父类")]),t._v(" "),e("h3",{attrs:{id:"_2-1"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1"}},[t._v("#")]),t._v(" 2.1")]),t._v(" "),e("h3",{attrs:{id:"_2-2-虚函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-虚函数"}},[t._v("#")]),t._v(" 2.2 虚函数")]),t._v(" "),e("p",[t._v("在基类和派生类对应的函数前添加virtual关键字。\noverride关键字\n派生类可以在它覆盖的函数前使用virtual关键字，但不是非得这么做。C++11中，允许显示注明它使用某个成员函数覆盖了它继承的虚函数，在函数后添加关键字override，这样做的好处是，使得程序员的意图更加清晰的同时，还可以让编译器发现一些错误。")]),t._v(" "),e("p",[t._v("与重定义进行区分：\n重定义：派生类的函数屏蔽了与其同名的基类函数，规则如下：")]),t._v(" "),e("ol",[e("li",[t._v("如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual，基类的函数被隐藏。")]),t._v(" "),e("li",[t._v("如果派生类的函数与基类的函数同名，并且参数也相同，但是基函数没有virtual关键字，此时，基类的函数被隐藏。")])]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('class A {\npublic:\n\tA() { cout << "A constructor" << endl; }\n\tvirtual ~A(){}\n\tvirtual void test() { cout << "A test()" << endl; }\n};\nclass B : public A {\npublic:\n\tB() { cout << "B constructor" << endl; }\n\tvirtual ~B() {}\n\tvoid test(int a) { cout << "B test(int)" << endl; }\n};\nint main(){\n  B* pB = new B;\n  pB->test();//error : 函数中调用的参数太少,因为此时基类的函数被隐藏.\n}\n')])])]),e("h3",{attrs:{id:"_2-3-纯虚函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-纯虚函数"}},[t._v("#")]),t._v(" 2.3 纯虚函数")]),t._v(" "),e("p",[t._v("virtual void test() = 0;\n一个具有纯虚函数的基类称为抽象类.")]),t._v(" "),e("h3",{attrs:{id:"_2-3-虚继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-虚继承"}},[t._v("#")]),t._v(" 2.3 虚继承")]),t._v(" "),e("p",[t._v("菱形继承(继承路径上有一个公共的基类)，会产生二义性，公共基类会在派生类的对象中产生多个基类子对象，为了解决以上问题，必须对这个基类声明为虚继承，使这个基类成为虚基类。")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class A{public: int a;};\nclass B : virtual public A{public: int b;};\nclass C : virtual public A{public: int c;};\nclass D : public B, public C{public: int d;}\n//调用类的顺序为：A-B-C-D\n")])])]),e("p",[t._v("虚继承会生成虚基表和虚基表指针。\n虚继承的内存结构\n虚继承的内存结构和普通继承的内存结构是不同的，虚基类会在子类结构中被整合到后部。\n上述案例中的内存结构为")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("内存")]),t._v(" "),e("th",{staticStyle:{"text-align":"right"}},[t._v("数据")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("ec0")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("B类虚基表指针")])]),t._v(" "),e("tr",[e("td",[t._v("ec8")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("b")])]),t._v(" "),e("tr",[e("td",[t._v("ed0")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("C类虚基表指针")])]),t._v(" "),e("tr",[e("td",[t._v("ed8")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("c")])]),t._v(" "),e("tr",[e("td",[t._v("ee0")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("d")])]),t._v(" "),e("tr",[e("td",[t._v("eec")]),t._v(" "),e("td",{staticStyle:{"text-align":"right"}},[t._v("a")])])])]),t._v(" "),e("p",[t._v("具体情况可写代码进行测试")]),t._v(" "),e("h2",{attrs:{id:"_3-多态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-多态"}},[t._v("#")]),t._v(" 3 多态")]),t._v(" "),e("p",[t._v("动态绑定只有通过指针或引用调用虚函数时才会发生。\n当通过一个具有普通烈性（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。")]),t._v(" "),e("h3",{attrs:{id:"_3-1-多态的实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-多态的实现原理"}},[t._v("#")]),t._v(" 3.1 多态的实现原理")]),t._v(" "),e("p",[t._v("当类中声明虚函数时,编译器会在类中生成一个虚函数表,虚函数表时一个存储类成员函数指针的数据结构,虚函数表时由编译器自动生成与维护的.")]),t._v(" "),e("p",[t._v("声明在内层作用域的函数不会重载声明在外层作用域的函数。")]),t._v(" "),e("h2",{attrs:{id:"_4-衍生出的设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-衍生出的设计模式"}},[t._v("#")]),t._v(" 4 衍生出的设计模式")]),t._v(" "),e("h3",{attrs:{id:"_4-1-单例模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-单例模式"}},[t._v("#")]),t._v(" 4.1 单例模式")]),t._v(" "),e("h3",{attrs:{id:"_4-2-观察者模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-观察者模式"}},[t._v("#")]),t._v(" 4.2 观察者模式")]),t._v(" "),e("p",[t._v("委托+继承")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class Subject{\n  int m_value;\n  vector<Observer*> m_views;\npublic:\n  void attach(Observer* obs){\n    m_views.push_back(obs);\n  }\n  void set_val(int value){\n    m_value = value;\n    notify();\n  }\n  void motify(){\n    for(int i = 0; i < m_views.size(); ++i){\n      m_views[i]->update(this, m_value);\n    }\n  }\n};\nclass Observer{\npublic:\n  virtual void update(Subject* sub, int value) = 0;\n};\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);