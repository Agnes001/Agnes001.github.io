(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{408:function(t,e,s){"use strict";s.r(e);var n=s(46),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"drogon概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#drogon概述"}},[t._v("#")]),t._v(" drogon概述")]),t._v(" "),s("p",[s("strong",[t._v("Drogon")]),t._v("是一个基于C++14/17的Http应用框架，使用Drogon可以方便的使用C++构建各种类型的Web应用服务端程序。")]),t._v(" "),s("p",[t._v("Drogon的主要应用平台是Linux，也支持Mac OS、FreeBSD和Windows。它的主要特点如下：")]),t._v(" "),s("ul",[s("li",[t._v("网络层使用基于epoll(macOS/FreeBSD下是kqueue)的非阻塞IO框架，提供高并发、高性能的网络IO。详细请见"),s("a",{attrs:{href:"https://www.techempower.com/benchmarks/#section=data-r19&hw=ph&test=composite",target:"_blank",rel:"noopener noreferrer"}},[t._v("TFB Tests Results"),s("OutboundLink")],1),t._v("；")]),t._v(" "),s("li",[t._v("全异步编程模式；")]),t._v(" "),s("li",[t._v("支持Http1.0/1.1(server端和client端)；")]),t._v(" "),s("li",[t._v("基于template实现了简单的反射机制，使主程序框架、控制器(controller)和视图(view)完全解耦；")]),t._v(" "),s("li",[t._v("支持cookies和内建的session；")]),t._v(" "),s("li",[t._v("支持后端渲染，把控制器生成的数据交给视图生成Html页面，视图由CSP模板文件描述，通过CSP标签把C++代码嵌入到Html页面，由drogon的命令行工具在编译阶段自动生成C++代码并编译；")]),t._v(" "),s("li",[t._v("支持运行期的视图页面动态加载(动态编译和加载so文件)；")]),t._v(" "),s("li",[t._v("非常方便灵活的路径(path)到控制器处理函数(handler)的映射方案；")]),t._v(" "),s("li",[t._v("支持过滤器(filter)链，方便在控制器之前执行统一的逻辑(如登录验证、Http Method约束验证等)；")]),t._v(" "),s("li",[t._v("支持https(基于OpenSSL实现);")]),t._v(" "),s("li",[t._v("支持websocket(server端和client端);")]),t._v(" "),s("li",[t._v("支持Json格式请求和应答, 对Restful API应用开发非常友好;")]),t._v(" "),s("li",[t._v("支持文件下载和上传,支持sendfile系统调用；")]),t._v(" "),s("li",[t._v("支持gzip/brotli压缩传输；")]),t._v(" "),s("li",[t._v("支持pipelining；")]),t._v(" "),s("li",[t._v("提供一个轻量的命令行工具drogon_ctl，帮助简化各种类的创建和视图代码的生成过程；")]),t._v(" "),s("li",[t._v("基于非阻塞IO实现的异步数据库读写，目前支持PostgreSQL和MySQL(MariaDB)数据库；")]),t._v(" "),s("li",[t._v("基于线程池实现sqlite3数据库的异步读写，提供与上文数据库相同的接口；")]),t._v(" "),s("li",[t._v("支持ARM架构；")]),t._v(" "),s("li",[t._v("方便的轻量级ORM实现，支持常规的对象到数据库的双向映射操作；")]),t._v(" "),s("li",[t._v("支持插件，可通过配置文件在加载期动态拆装；")]),t._v(" "),s("li",[t._v("支持内建插入点的AOP")])]),t._v(" "),s("h1",{attrs:{id:"drogon安装"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#drogon安装"}},[t._v("#")]),t._v(" drogon安装")]),t._v(" "),s("h2",{attrs:{id:"准备工作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#准备工作"}},[t._v("#")]),t._v(" 准备工作")]),t._v(" "),s("h4",{attrs:{id:"环境"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#环境"}},[t._v("#")]),t._v(" 环境")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apt")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apt")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" gcc\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apt")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" g++\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apt")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" cmake\n")])])]),s("h4",{attrs:{id:"jsoncpp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jsoncpp"}},[t._v("#")]),t._v(" jsoncpp")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apt")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" libjsoncpp-dev\n")])])]),s("h4",{attrs:{id:"uuid"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#uuid"}},[t._v("#")]),t._v(" uuid")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apt")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" uuid-dev\n")])])]),s("h4",{attrs:{id:"openssl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#openssl"}},[t._v("#")]),t._v(" OpenSSL")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apt")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" openssl\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apt")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" libssl-dev\n")])])]),s("h4",{attrs:{id:"zlib"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#zlib"}},[t._v("#")]),t._v(" zlib")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apt")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" zlib1g-dev\n")])])]),s("h2",{attrs:{id:"安装drogon"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#安装drogon"}},[t._v("#")]),t._v(" 安装drogon")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("cd")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$WORK_PATH")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" clone https://github.com/an-tao/drogon\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("cd")]),t._v(" drogon\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("git")]),t._v(" submodule update --init\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("mkdir")]),t._v(" build\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("cd")]),t._v(" build\ncmake "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("make")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sudo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("make")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v("\n")])])]),s("p",[t._v("默认是编译debug版本，如果想编译release版本，cmake命令要带如下参数：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("cmake -DCMAKE_BUILD_TYPE"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("Release "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(" \n")])])]),s("p",[t._v("安装结束后，将有如下文件被安装在系统中(CMAKE_INSTALL_PREFIX可以改变安装位置)：")]),t._v(" "),s("ul",[s("li",[t._v("drogon的头文件被安装到/usr/local/include/drogon中；")]),t._v(" "),s("li",[t._v("drogon的库文件libdrogon.a被安装到/usr/local/lib中；")]),t._v(" "),s("li",[t._v("drogon的命令行工具drogon_ctl被安装到/usr/local/bin中；")]),t._v(" "),s("li",[t._v("trantor的头文件被安装到/usr/local/include/trantor中；")]),t._v(" "),s("li",[t._v("trantor的库文件libtrantor.a被安装到/usr/local/lib中；")])]),t._v(" "),s("h1",{attrs:{id:"drogon简单使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#drogon简单使用"}},[t._v("#")]),t._v(" drogon简单使用")]),t._v(" "),s("h2",{attrs:{id:"静态网站"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态网站"}},[t._v("#")]),t._v(" 静态网站")]),t._v(" "),s("p",[t._v("我们从一个最简单的例子开始介绍drogon的使用，在这个例子中我们使用命令行工具drogon_ctl创建一个工程：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("drogon_ctl create project your_project_name\n")])])]),s("p",[t._v("进入工程目录，可以看到如下文件:")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("├── build                         构建文件夹\n├── CMakeLists.txt                工程的cmake配置文件\n├── config.json                   drogon应用的配置文件\n├── controllers                   存放控制器文件的目录\n├── filters                       存放过滤器文件的目录\n├── main.cc                       主程序\n├── models                        数据库模型文件的目录\n│   └── model.json\n└── views                         存放视图csp文件的目录\n")])])]),s("p",[t._v("main.cc文件，内容如下：")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('#include <drogon/HttpAppFramework.h>\nint main() {\n    //Set HTTP listener address and port\n    drogon::app().addListener("0.0.0.0",80);\n    //Load config file\n    //drogon::app().loadConfigFile("../config.json");\n    //Run HTTP framework,the method will block in the internal event loop\n    drogon::app().run();\n    return 0;\n}\n')])])]),s("p",[t._v("然后构建项目:")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("cd")]),t._v(" build\ncmake "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("make")]),t._v("\n")])])]),s("p",[t._v("编译完成后，运行目标程序"),s("code",[t._v("./your_project_name")]),t._v(".")]),t._v(" "),s("p",[t._v("现在，我们在Http根目录添加一个最简单的静态文件index.html:")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'<h1>Hello Drogon!</h1>'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v("index.html\n")])])]),s("p",[t._v("Http根目录默认值是"),s("code",[t._v('"./"')]),t._v("， 也就是webapp程序运行的当前路径， Http根目录也可在config.json配置文件中进行更改，可参见"),s("a",{attrs:{href:"CHN-10-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"}},[t._v("配置文件")]),t._v("， 然后在地址栏输入"),s("code",[t._v("http://localhost")]),t._v("或"),s("code",[t._v("http://localhost/index.html")]),t._v("(或者你的webapp所在服务器的ip)可以访问到这个页面，如果服务器找不到浏览器访问的页面，将返回404页面。")]),t._v(" "),s("p",[s("strong",[t._v("注意：请确认服务器的防火墙已经打开80端口，否则你看不到这些页面。")])]),t._v(" "),s("p",[t._v('我们可以把一个静态网站的目录和文件复制到这个webapp的运行目录，然后通过浏览器就可以访问到它们，drogon默认支持的文件类型有"html","js","css","xml","xsl","txt","svg","ttf","otf","woff2","woff","eot","png","jpg","jpeg","gif","bmp","ico","icns"等等。')]),t._v(" "),s("h2",{attrs:{id:"动态网站"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#动态网站"}},[t._v("#")]),t._v(" 动态网站")]),t._v(" "),s("p",[t._v("下面我们看看怎么给这个应用添加控制器（controller）,并使用控制器（controller）输出内容。")]),t._v(" "),s("p",[t._v("在"),s("code",[t._v("controller")]),t._v("目录下运行drogon_ctl命令行工具生成控制器（controller）源文件:")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("drogon_ctl create controller TestCtrl\n")])])]),s("p",[t._v("可以看到，目录下新增加了两个文件，TestCtrl.h和TestCtrl.cc:")]),t._v(" "),s("p",[t._v("TestCtrl.h如下：")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('#pragma once\n#include <drogon/HttpSimpleController.h>\nusing namespace drogon;\nclass TestCtrl:public drogon::HttpSimpleController<TestCtrl>\n{\npublic:\n    virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,\n                                        std::function<void (const HttpResponsePtr &)> &&callback)override;\n    PATH_LIST_BEGIN\n    //list path definitions here;\n    //PATH_ADD("/path","filter1","filter2",HttpMethod1,HttpMethod2...);\n    PATH_LIST_END\n};\n')])])]),s("p",[t._v("TestCtrl.cc如下：")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('#include "TestCtrl.h"\nvoid TestCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req,\n                                      std::function<void (const HttpResponsePtr &)> &&callback)\n{\n    //write your application logic here\n}\n')])])]),s("p",[t._v("我们编辑一下这两个文件，让这个控制器处理函数回应一个简单的“Hello World!”。")]),t._v(" "),s("p",[t._v("TestCtrl.h如下：")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('#pragma once\n#include <drogon/HttpSimpleController.h>\nusing namespace drogon;\nclass TestCtrl:public drogon::HttpSimpleController<TestCtrl>\n{\npublic:\n    virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,\n                                        std::function<void (const HttpResponsePtr &)> &&callback)override;\n    PATH_LIST_BEGIN\n    //list path definitions here;\n    //PATH_ADD("/path","filter1","filter2",HttpMethod1,HttpMethod2...);\n    PATH_ADD("/",Get,Post);\n    PATH_ADD("/test",Get);\n    PATH_LIST_END\n};\n')])])]),s("p",[t._v("使用PATH_ADD添加路径到处理函数的映射，这里映射了两个路径'/'和'/test',并在路径后面添加了对这个路径的约束。")]),t._v(" "),s("p",[t._v("TestCtrl.cc如下：")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('#include "TestCtrl.h"\nvoid TestCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req,\n                                      std::function<void (const HttpResponsePtr &)> &&callback)\n{\n    //write your application logic here\n    auto resp=HttpResponse::newHttpResponse();\n    resp->setStatusCode(k200OK);\n    resp->setContentTypeCode(CT_TEXT_HTML);\n    resp->setBody("Hello World!");\n    callback(resp);\n}\n')])])]),s("p",[t._v("重新用cmake编译这个工程，然后运行目标程序"),s("code",[t._v("./your_project_name")]),t._v("：")]),t._v(" "),s("div",{staticClass:"language-shelll extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("cd ../build\ncmake ..\nmake\n./your_project_name\n")])])]),s("p",[t._v("在浏览器地址栏输入"),s("code",[t._v("http://localhost/")]),t._v("或者"),s("code",[t._v("http://localhost/test")]),t._v("，你就可以在浏览器看到"),s("code",[t._v("Hello World!")]),t._v("了。")]),t._v(" "),s("p",[s("strong",[t._v("注意: 同时存在静态和动态资源的情况下，框架优先使用控制器响应请求，此例中"),s("code",[t._v("http://localhost/")]),t._v(" 响应的是"),s("code",[t._v("TestCtrl")]),t._v("控制器的输出"),s("code",[t._v("Hello Word！")]),t._v("而不是静态网页"),s("code",[t._v("index.html")]),t._v("的"),s("code",[t._v("Hello Drogon！")])])]),t._v(" "),s("p",[t._v("我们看到，在应用中添加controller非常简单，只需要添加对应的源文件即可，甚至main文件不用做任何修改，这种低耦合度的设计对web应用开发是非常有效的。")]),t._v(" "),s("p",[s("strong",[t._v("注意: Drogon没有限制控制器（controller）源文件的位置，也可以放在工程目录下，甚至可以在"),s("code",[t._v("CMakeLists.txt")]),t._v("中指定到新的目录中，为了方便管理，建议将控制器源文件放在controllers目录。")])]),t._v(" "),s("h1",{attrs:{id:"控制器-controller"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#控制器-controller"}},[t._v("#")]),t._v(" 控制器(controller)")]),t._v(" "),s("p",[t._v("控制器(controller)在web应用开发中处于相当重要的地位，"),s("strong",[t._v("它处理浏览器发来的请求，然后生成响应发送给浏览器")]),t._v("；drogon框架已经帮我们处理好网络传输、Http协议的解析等等细节，我们只需要关注控制器的逻辑即可；每一个控制器对象可以有一个或者多个处理函数(一般称为handler)，函数的接口，一般定义成如下形式：")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("void handlerName(const HttpRequestPtr &req,\n                   std::function<void (const HttpResponsePtr &)> &&callback,\n                  ...);\n")])])]),s("p",[t._v("其中，"),s("code",[t._v("req")]),t._v("是Http请求的对象(被智能指针包裹)，"),s("code",[t._v("callback")]),t._v("是框架传给控制器的回调函数对象，控制器生成应答对象(也通过智能指针包裹)后，通过callback把该对象传给drogon，然后框架会帮你把响应内容发送给浏览器，最后面的是若干参数列表"),s("code",[t._v("...")]),t._v("，由drogon根据映射规则把Http请求中的参数映射到对应的handler的形参上，这是对应用开发是非常方便的。")]),t._v(" "),s("p",[t._v("很明显，这是个异步接口，用户可以在其它线程完成耗时操作后再调用callback；")]),t._v(" "),s("p",[t._v("drogon的控制器分为三种类型，"),s("code",[t._v("HttpSimpleController")]),t._v(","),s("code",[t._v("HttpController")]),t._v("和"),s("code",[t._v("WebSocketController")]),t._v('，用户使用时，需要继承相应的类模板，比如，一个HttpSimpleController的自定义类"MyClass"声明如下：')]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('class MyClass:public drogon::HttpSimpleController<MyClass>\n{\npublic:\n    //TestController(){}\n    virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,\n                                         std::function<void (const HttpResponsePtr &)> &&callback) override;\n\n    PATH_LIST_BEGIN\n    PATH_ADD("/json");\n    PATH_LIST_END\n};\n')])])]),s("h2",{attrs:{id:"控制器的生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#控制器的生命周期"}},[t._v("#")]),t._v(" 控制器的生命周期")]),t._v(" "),s("p",[t._v("注册到drogon框架的控制器最多只会有一个实例，在整个应用运行期间都不会销毁，所以，用户可以在控制器类中声明和使用成员变量。注意，控制器的handler被调用时，是在多线程环境下的（当框架的IO线程数配置成大于1的值时），如果需要访问非临时变量，请做好并发保护工作。")]),t._v(" "),s("h2",{attrs:{id:"httpsimplecontroller"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#httpsimplecontroller"}},[t._v("#")]),t._v(" HttpSimpleController")]),t._v(" "),s("p",[t._v("可以由"),s("code",[t._v("drogon_ctl")]),t._v("命令行工具快速生成基于"),s("code",[t._v("HttpSimpleController")]),t._v("的自定义类的源文件，命令格式如下：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("drogon_ctl create controller "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("namespace::"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("class_name"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),s("p",[t._v("我们创建一个名称为"),s("code",[t._v("TestCtrl")]),t._v("的控制器：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("drogon_ctl create controller TestCtrl\n")])])]),s("p",[t._v("可以看到，目录下新增加了两个文件，TestCtrl.h和TestCtrl.cc，下面阐述一下这两个文件。")]),t._v(" "),s("p",[t._v("TestCtrl.h如下：")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('#pragma once\n#include <drogon/HttpSimpleController.h>\nusing namespace drogon;\nclass TestCtrl:public drogon::HttpSimpleController<TestCtrl>\n{\npublic:\n    virtual void asyncHandleHttpRequest(const HttpRequestPtr &req,\n                                        std::function<void (const HttpResponsePtr &)> &&callback)override;\n    PATH_LIST_BEGIN\n    //list path definitions here;\n    //PATH_ADD("/path","filter1","filter2",HttpMethod1,HttpMethod2...);\n    PATH_LIST_END\n};\n')])])]),s("p",[t._v("TestCtrl.cc如下：")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('#include "TestCtrl.h"\nvoid TestCtrl::asyncHandleHttpRequest(const HttpRequestPtr &req,\n                                      std::function<void (const HttpResponsePtr &)> &&callback)\n{\n    //write your application logic here\n}\n')])])]),s("p",[t._v("每个HttpSimpleController类只能定义一个Http请求处理函数(handler)，而且通过虚函数重载定义。")]),t._v(" "),s("p",[t._v("从URL路径到处理函数的路由(或称映射)由宏完成，可以用"),s("code",[t._v("PATH_ADD")]),t._v("宏添加多重路径映射，所有"),s("code",[t._v("PATH_ADD")]),t._v("语句应夹在"),s("code",[t._v("PATH_LIST_BEGIN")]),t._v("和"),s("code",[t._v("PATH_LIST_END")]),t._v("宏语句之间。")]),t._v(" "),s("p",[t._v("第一个参数是映射的路径,路径后面的参数是对这个路径的约束，目前支持两种约束，一种是"),s("code",[t._v("HttpMethod")]),t._v("类型，表示该路径允许使用的Http方法，可以配置零个或多个，一种是"),s("code",[t._v("HttpFilter")]),t._v("类的名字，这种对象执行特定的过滤操作，也可以配置0个或多个，两种类型没有顺序要求，框架会处理好类型的匹配。")]),t._v(" "),s("p",[t._v("用户可以把同一个Simple Controller注册到多个路径上，也可以在同一个路径上注册多个Simple Controller（通过HTTP method区分）。")]),t._v(" "),s("p",[t._v("你可以定义一个HttpResponse类的变量，然后使用callback()返回这个变量即可:")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('    //write your application logic here\n    auto resp=HttpResponse::newHttpResponse();\n    resp->setStatusCode(k200OK);\n    resp->setContentTypeCode(CT_TEXT_HTML);\n    resp->setBody("Your Page Contents");\n    callback(resp);\n')])])]),s("p",[s("strong",[t._v("上述路径到处理函数的映射是在编译期完成的，事实上，drogon框架也提供了运行期完成映射的接口，运行期映射可以让用户通过配置文件或其它用户接口完成映射或修改映射关系而无需重新编译这个程序(出于性能的考虑，禁止在运行app().run()之后再注册任何映射)。")])]),t._v(" "),s("h2",{attrs:{id:"httpcontroller"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#httpcontroller"}},[t._v("#")]),t._v(" HttpController")]),t._v(" "),s("h3",{attrs:{id:"生成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生成"}},[t._v("#")]),t._v(" 生成")]),t._v(" "),s("p",[t._v("可以由"),s("code",[t._v("drogon_ctl")]),t._v("命令行工具快速生成基于"),s("code",[t._v("HttpController")]),t._v("的自定义类的源文件，命令格式如下：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("drogon_ctl create controller -h "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("namespace::"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("class_name"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n")])])]),s("p",[t._v("我们创建一个位于"),s("code",[t._v("demo v1")]),t._v("名称空间内且名称为"),s("code",[t._v("User")]),t._v("的控制器：")]),t._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[t._v("drogon_ctl create controller -h demo::v1::User\n")])])]),s("p",[t._v("可以看到，目录下新增加了两个文件，demo_v1_User.h和demo_v1_User.cc:")]),t._v(" "),s("p",[t._v("demo_v1_User.h如下:")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("#pragma once\n#include <drogon/HttpController.h>\nusing namespace drogon;\nnamespace demo\n{\n    namespace v1\n    {\n        class User:public drogon::HttpController<User>\n        {\n        public:\n            METHOD_LIST_BEGIN\n                //use METHOD_ADD to add your custom processing function here;\n            METHOD_LIST_END\n            //your declaration of processing function maybe like this:\n        };\n    }\n}\n")])])]),s("p",[t._v("demo_v1_User.cc如下：")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('#include "demo_v1_User.h"\nusing namespace demo::v1;\n//add definition of your processing function here\n')])])]),s("h3",{attrs:{id:"使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),s("p",[t._v("我们编辑一下这两个文件，然后再阐述它们。")]),t._v(" "),s("p",[t._v("demo_v1_User.h如下：")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('#pragma once\n#include <drogon/HttpController.h>\nusing namespace drogon;\nnamespace demo\n{\n    namespace v1\n    {\n        class User:public drogon::HttpController<User>\n        {\n        public:\n            METHOD_LIST_BEGIN\n                //use METHOD_ADD to add your custom processing function here;\n                METHOD_ADD(User::login,"/token?userId={1}&passwd={2}",Post);\n                METHOD_ADD(User::getInfo,"/{1}/info?token={2}",Get);\n            METHOD_LIST_END\n            //your declaration of processing function maybe like this:\n            void login(const HttpRequestPtr &req,\n                       std::function<void (const HttpResponsePtr &)> &&callback,\n                       std::string &&userId,\n                       const std::string &password);\n            void getInfo(const HttpRequestPtr &req,\n                         std::function<void (const HttpResponsePtr &)> &&callback,\n                         std::string userId,\n                         const std::string &token) const;\n        };\n    }\n}\n')])])]),s("p",[t._v("demo_v1_User.cc如下：")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('#include "demo_v1_User.h"\nusing namespace demo::v1;\n//add definition of your processing function here\n\nvoid User::login(const HttpRequestPtr &req,\n           std::function<void (const HttpResponsePtr &)> &&callback,\n           std::string &&userId,\n           const std::string &password)\n{\n    LOG_DEBUG<<"User "<<userId<<" login";\n    //认证算法，读数据库，验证身份等...\n    //...\n    Json::Value ret;\n    ret["result"]="ok";\n    ret["token"]=drogon::utils::getUuid();\n    auto resp=HttpResponse::newHttpJsonResponse(ret);\n    callback(resp);\n}\nvoid User::getInfo(const HttpRequestPtr &req,\n             std::function<void (const HttpResponsePtr &)> &&callback,\n             std::string userId,\n            const std::string &token) const\n{\n    LOG_DEBUG<<"User "<<userId<<" get his information";\n    //验证token有效性等\n    //读数据库或缓存获取用户信息\n    Json::Value ret;\n    ret["result"]="ok";\n    ret["user_name"]="Jack";\n    ret["user_id"]=userId;\n    ret["gender"]=1;\n    auto resp=HttpResponse::newHttpJsonResponse(ret);\n    callback(resp);\n}\n')])])]),s("p",[t._v("每个"),s("code",[t._v("HttpController")]),t._v("类可以定义多个Http请求处理函数(handler)，由于函数数目可以任意多，所以通过虚函数重载是不现实的，我们需要把处理函数本身(而不是类)注册到框架里去。")]),t._v(" "),s("p",[t._v("从URL路径到处理函数的映射由宏完成，可以用"),s("code",[t._v("METHOD_ADD")]),t._v("宏或"),s("code",[t._v("ADD_METHOD_TO")]),t._v("宏添加多重路径映射，所有"),s("code",[t._v("METHOD_ADD")]),t._v("和"),s("code",[t._v("ADD_METHOD_TO")]),t._v("语句应夹在"),s("code",[t._v("METHOD_LIST_BEGIN")]),t._v("和"),s("code",[t._v("METHOD_LIST_END")]),t._v("宏语句之间。")]),t._v(" "),s("p",[s("code",[t._v("METHOD_ADD")]),t._v("宏会在路径映射中自动把"),s("strong",[t._v("名字空间和类名")]),t._v("作为路径的前缀，所以，本例子中，login函数，被注册到了"),s("code",[t._v("/demo/v1/user/token")]),t._v("路径上，getInfo函数被注册到了"),s("code",[t._v("/demo/v1/user/xxx/info")]),t._v("路径上。后面的约束跟HttpSimpleController的PATH_ADD宏类似，不再赘述。")]),t._v(" "),s("p",[t._v("如果使用了自动的前缀，访问地址要包含命名空间和类名，此例中要使用"),s("code",[t._v("http://localhost/demo/v1/user/token?userid=xxx&passwd=xxx")]),t._v("或者"),s("code",[t._v("http://localhost/demo/v1/user/xxxxx/info?token=xxxx")]),t._v("来访问。")]),t._v(" "),s("p",[s("code",[t._v("ADD_METHOD_TO")]),t._v("宏的作用与前者几乎一样，除了它不会自动添加任何前缀，即这个宏注册的路径是一个绝对路径。")]),t._v(" "),s("p",[t._v("我们看到，"),s("code",[t._v("HttpController")]),t._v("提供了更为灵活的路径映射功能，并且可以注册多个处理函数，我们可以把一类功能放在一个类里。")]),t._v(" "),s("p",[t._v("另外可以看到，"),s("code",[t._v("METHOD_ADD")]),t._v("宏提供了参数映射的方法，我们可以把路径上的参数映射到函数的参数表里，由参数的数码对应形参的位置，非常方便，常见的可以由字符串类型转换的类型都可以作为参数(如std::string,int,float,double等等)，框架基于模板的类型推断会自动帮你转换类型，非常方便。注意左值引用必须是const类型。")]),t._v(" "),s("p",[t._v("同一个路径还可以注册多次，相互之间通过Http Method区分，这是合法的，并且是Restful API的通常做法，比如")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v(' METHOD_LIST_BEGIN\n     METHOD_ADD(Book::getInfo,"/{1}?detail={2}",Get);\n     METHOD_ADD(Book::newBook,"/{1}",Post);\n     METHOD_ADD(Book::deleteOne,"/{1}",Delete);\n METHOD_LIST_END\n')])])]),s("p",[t._v("路径参数的占位符有多种写法:")]),t._v(" "),s("ul",[s("li",[t._v("{}: 表示这个路径参数映射到处理函数的对应位置上，路径上的位置就是函数参数的位置。")]),t._v(" "),s("li",[t._v("{1},{2}: 中间有个数字的，表示映射到数字指定的处理函数参数上。")]),t._v(" "),s("li",[t._v("{anystring}: 中间的字符串没有实际作用，但可以提高程序的可读性，与"),s("code",[t._v("{}")]),t._v("等价。")]),t._v(" "),s("li",[t._v("{1:anystring},{2:xxx}: 冒号前的数字表示位置，后面的字符串没有实际作用，但可以提高程序的可读性，与"),s("code",[t._v("{1}")]),t._v(","),s("code",[t._v("{2}")]),t._v("等价。")])]),t._v(" "),s("p",[t._v("推荐使用后两种写法，如果路径参数和函数参数顺序一直，使用第三种写法即可。容易知道，以下几种写法是等价的：")]),t._v(" "),s("ul",[s("li",[t._v('"/users/{}/books/{}"')]),t._v(" "),s("li",[t._v('"/users/{}/books/{2}"')]),t._v(" "),s("li",[t._v('"/users/{user_id}/books/{book_id}"')]),t._v(" "),s("li",[t._v('"/users/{1:user_id}/books/{2}"')])]),t._v(" "),s("p",[s("strong",[t._v("注意：路径匹配大小写不敏感，参数名字大小写敏感，参数值大小写保持原貌")])]),t._v(" "),s("h3",{attrs:{id:"参数映射"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参数映射"}},[t._v("#")]),t._v(" 参数映射")]),t._v(" "),s("p",[t._v("通过前面的叙述我们知道，路径上的参数和问号后面的请求参数都可以映射到处理函数的参数列表里，目标参数的类型需要满足如下条件：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("必须是值类型、常左值引用或非const右值引用中的一种，不能是非const的左值引用，推荐使用右值引用，这样用户可以随意处置它；")])]),t._v(" "),s("li",[s("p",[t._v("int, long, long long, unsigned long, unsigned long long, float, double, long double等基础类型都可以作为参数类型；")])]),t._v(" "),s("li",[s("p",[t._v("std::string类型；")])]),t._v(" "),s("li",[s("p",[t._v("任何可以使用"),s("code",[t._v("stringstream >>")]),t._v("操作符赋值的类型；")])])]),t._v(" "),s("p",[s("strong",[t._v("另外，drogon框架还提供了从HttpRequestPtr对象到任意类型的参数的映射机制")]),t._v("，当你的handler参数列表中映射参数的数量多于路径上的参数时，后面多余的参数将由HttpRequestPtr对象转换得到，用户可以定义任意类型的转换，定义这种转换的方式是特化drogon命名空间的fromRequest模板(定义于HttpRequest.h头文件))，比如我们需要做一个创建新用户的RESTful的接口，我们定义用户的结构体如下：")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('namespace myapp{\nstruct User{\n    std::string userName;\n    std::string email;\n    std::string address;\n};\n}\nnamespace drogon\n{\ntemplate <>\ninline myapp::User fromRequest(const HttpRequest &req)\n{\n    auto json = req.getJsonObject();\n    myapp::User user;\n    if(json)\n    {\n        user.userName = (*json)["name"].asString();\n        user.email = (*json)["email"].asString();\n        user.address = (*json)["address"].asString();\n    }\n    return user;\n}\n\n}\n')])])]),s("p",[t._v("有了上面的定义和模板特化，我们就可以向下面这样定义路径和handler:")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('class UserController:public drogon::HttpController<UserController>\n{\npublic:\n    METHOD_LIST_BEGIN\n        //use METHOD_ADD to add your custom processing function here;\n        ADD_METHOD_TO(UserController::newUser,"/users",Post);\n    METHOD_LIST_END\n    //your declaration of processing function maybe like this:\n    void newUser(const HttpRequestPtr &req,\n                 std::function<void (const HttpResponsePtr &)> &&callback,\n                 myapp::User &&pNewUser) const;\n};\n')])])]),s("p",[t._v("可以看到，第三个"),s("code",[t._v("myapp::User")]),t._v("类型的参数在映射路径上没有对应的占位符，框架会将它视为由"),s("code",[t._v("req")]),t._v("对象转换的参数，通过用户特化的函数模板得到这个参数，这都是drogon通过模板推导自动在编译期完成的，为用户的开发提供了极大便利。")]),t._v(" "),s("p",[t._v("更进一步，有些用户除了他们自定义类型的数据外，并不需要访问HttpRequestPtr对象，那么他可以把这个自定义的对象放在第一个参数的位置，框架也能正确完成映射，比如上面的例子也可以写成下面这样:")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('class UserController:public drogon::HttpController<UserController>\n{\npublic:\n    METHOD_LIST_BEGIN\n        //use METHOD_ADD to add your custom processing function here;\n        ADD_METHOD_TO(UserController::newUser,"/users",Post);\n    METHOD_LIST_END\n    //your declaration of processing function maybe like this:\n    void newUser(myapp::User &&pNewUser,\n                 std::function<void (const HttpResponsePtr &)> &&callback) const;\n};\n')])])]),s("h3",{attrs:{id:"多路径映射"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多路径映射"}},[t._v("#")]),t._v(" 多路径映射")]),t._v(" "),s("p",[t._v("drogon支持在路径映射中使用正则表达式，在"),s("code",[t._v("{}")]),t._v("花括号以外的部分可以有限制的使用，比如")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('ADD_METHOD_TO(UserController::handler1,"/users/.*",Post); /// Match any path prefixed with `/users/`\nADD_METHOD_TO(UserController::handler2,"/{name}/[0-9]+",Post); ///Match any path composed with a name string and a number.\n')])])]),s("p",[t._v("这种方法不支持子表达式，负向匹配等正则表达式，如果想使用他们，请用如下的方案。")]),t._v(" "),s("h3",{attrs:{id:"正则表达式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#正则表达式"}},[t._v("#")]),t._v(" 正则表达式")]),t._v(" "),s("p",[t._v("上面的方法对正则表达式的支持比较有限，如果用户想自由使用正则表达式，drogon提供了"),s("code",[t._v("ADD_METHOD_VIA_REGEX")]),t._v("宏来实现这一点，比如")]),t._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('ADD_METHOD_VIA_REGEX(UserController::handler1,"/users/(.*)",Post); /// Match any path prefixed with `/users/` and map the rest of the path to a parameter of the handler1.\nADD_METHOD_VIA_REGEX(UserController::handler2,"/.*([0-9]*)",Post); /// Matche any path that ends in a number and map that number to a parameter of the handler2.\nADD_METHOD_VIA_REGEX(UserController::handler3,"/(?!data).*",Post); /// Matches any path that does not start with \'/data\'\n')])])]),s("p",[t._v("可以看到，使用正则表达式也可以完成参数映射，所有子表达式匹配的字符串都会按顺序映射到handler的参数上。")]),t._v(" "),s("p",[s("strong",[t._v("需要注意的是，使用正则表达式要注意匹配冲突（多个不同的handler都匹配），当冲突发生在同一个controller内部时，drogon只会执行第一个handler（先注册进框架的那个handler），当冲突发生在不同controller之间时，执行哪个handler是不确定的，因此用户需要避免这种冲突发生。")])]),t._v(" "),s("h1",{attrs:{id:"附录"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#附录"}},[t._v("#")]),t._v(" 附录")]),t._v(" "),s("h2",{attrs:{id:"get和post请求的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#get和post请求的区别"}},[t._v("#")]),t._v(" get和post请求的区别")]),t._v(" "),s("ul",[s("li",[t._v("get可传的参数少；post可传数据大")]),t._v(" "),s("li",[t._v("get只能简单的在url上传参数；post有消息体，可存放大量数据")])])])}),[],!1,null,null,null);e.default=a.exports}}]);