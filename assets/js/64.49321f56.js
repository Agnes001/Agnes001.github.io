(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{446:function(t,e,n){"use strict";n.r(e);var a=n(46),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),n("p",[t._v("从平地到万丈高楼,万丈高楼平地起\n锱铢必较")])]),t._v(" "),n("p",[t._v("C++应用程序使用memory的途径")]),t._v(" "),n("div",{staticClass:"language-bash extra-class"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[t._v("C++ application\n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("     "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" c++ Library"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("std::allocator"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("     "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" c++ primitives"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("new,new"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(",::operator new"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(","),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("       "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" CRT"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("malloc/free"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("         "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n O.S.API"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("such as HeapAlloc,VisualAlloc,"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),n("h2",{attrs:{id:"primitives基础工具"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#primitives基础工具"}},[t._v("#")]),t._v(" primitives基础工具")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('void test_primitives()\n{\n\tcout << "\\ntest_primitives().......... \\n";\n\t\n    void* p1 = malloc(512);\t//512 bytes\n    free(p1);\n\n    complex<int>* p2 = new complex<int>; //one object\n    delete p2;             \n\n    void* p3 = ::operator new(512); //512 bytes\n    ::operator delete(p3);\n\n//以下使用 C++ 標準庫提供的 allocators。\n//其接口雖有標準規格，但實現廠商並未完全遵守；下面三者形式略異。\n#ifdef _MSC_VER\n    //以下兩函數都是 non-static，定要通過 object 調用。以下分配 3 個 ints.\n    int* p4 = allocator<int>().allocate(3, (int*)0); \n    allocator<int>().deallocate(p4,3);           \n#endif\n#ifdef __BORLANDC__\n    //以下兩函數都是 non-static，定要通過 object 調用。以下分配 5 個 ints.\n    int* p4 = allocator<int>().allocate(5);  \n    allocator<int>().deallocate(p4,5);       \n#endif\n#ifdef __GNUC__\n    //以下兩函數都是 static，可通過全名調用之。以下分配 512 bytes. 已不再使用\n    //void* p4 = alloc::allocate(512); \n    //alloc::deallocate(p4,512);   \n    \n    //以下兩函數都是 non-static，定要通過 object 調用。以下分配 7 個 ints.    \n\tvoid* p4 = allocator<int>().allocate(7); \n    allocator<int>().deallocate((int*)p4,7);     \n\t\n    //以下兩函數都是 non-static，定要通過 object 調用。以下分配 9 個 ints.\t\n\tvoid* p5 = __gnu_cxx::__pool_alloc<int>().allocate(9); \n    __gnu_cxx::__pool_alloc<int>().deallocate((int*)p5,9);\t\n#endif\n}\n')])])]),n("h2",{attrs:{id:"new-delete-expression"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new-delete-expression"}},[t._v("#")]),t._v(" new, delete expression")]),t._v(" "),n("h3",{attrs:{id:"new-expression"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new-expression"}},[t._v("#")]),t._v(" new expression")]),t._v(" "),n("p",[t._v("先分配内存，然后调用构造函数")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Complex* pc = new Complex(1, 2);\n    //||编译器转为\nComplex* pc;\ntry{\n    void* mem = operator new(sizeof(Complex));//里面调用的是malloc/_callnewh\n    pc = static_cast<Complex*>(mem);\n    pc->Complex::Complex(1, 2);\n    //注意：只有编译器才可以像上面那样调用Ctor\n}\ncatch(std::bad_alloc){\n    //...\n}    \n")])])]),n("h3",{attrs:{id:"delete-expression"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#delete-expression"}},[t._v("#")]),t._v(" delete expression")]),t._v(" "),n("p",[t._v("先调用析构函数，然后释放内存")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("delete pc;\n //||编译器转为\npc->~Complex();\noperator delete(pc);//里面调用free\n")])])]),n("h3",{attrs:{id:"ctor-dtor-直接调用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ctor-dtor-直接调用"}},[t._v("#")]),t._v(" Ctor & Dtor 直接调用")]),t._v(" "),n("p",[t._v("自己无法直接调用构造函数")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("    string* pstr = new string;\n//! pstr->string::string(\"jjhou\");  \n                        //[Error] 'class std::basic_string<char>' has no member named 'string'\n//! pstr->~string();\t//crash -- 其語法語意都是正確的, crash 只因為上一行被 remark 起來嘛.  \n")])])]),n("h2",{attrs:{id:"array-new-array-delete"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#array-new-array-delete"}},[t._v("#")]),t._v(" array new, array delete")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Complex* pca = new Complex[3];\n//调用3次ctor\ndelete[] pca; //调用3次dtor\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("特别注意加[]  \n```bash\n        |cookie         |\n  pca-> |Complex object |\n        |Complex object |\n        |Complex object |\n")])])]),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("size_t size = 3;\t\n{\n//模擬 memory pool 的作法, array new + placement new.  \n   \tA* buf = (A*)(new char[sizeof(A)*size]);//3次default ctor\n\n   \tA* tmp = buf;   \n   \tfor(int i = 0; i < size; ++i)\n\t    new (tmp++) A(i);  \t\t\t//3次有参ctor \n    \n    delete [] buf;    \t//3次dtor 逆序\n}\n")])])]),n("h3",{attrs:{id:"array-size-in-memory-block"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#array-size-in-memory-block"}},[t._v("#")]),t._v(" array size, in memory block")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("int* pi = new int[10];\ndelete pi;\n")])])]),n("p",[t._v("pi指向第一个数组，数组上边的一块内存用来存放数组长度。")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('void* operator new(size_t size) {\n    if (size == 0) size = 1;\n\n    void* ptr = malloc(size);\n    if (ptr == nullptr) {\n        std::cout << "ERROR NEW!" << std::endl;\n    }\n    std::cout << "NEW Memory Size = " << size << " address = " << ptr << std::endl;\n    return ptr;\n}\n\nvoid* operator new[](size_t size) {\n    if (size == 0) size = 1;\n\n    void* ptr = malloc(size);\n    if (ptr == nullptr) {\n        std::cout << "ERROR NEW[]!" << std::endl;\n    }\n    std::cout << "NEW[] Memory Size = " << size << " address = " << ptr << std::endl;\n\n    return ptr;\n}\nvoid operator delete(void* ptr) {\n    std::cout << "DELETE " << ptr << std::endl;\n    if (ptr) free(ptr);\n}\nvoid operator delete[](void* ptr) {\n    std::cout << "DELETE[] " << ptr << std::endl;\n    if (ptr) free(ptr);\n}\n//An allocation function shall be a class member function or a global function; a program is ill-formed if an allocation function is declared in a namespace scope other than global scope or declared static in global scope.\n//分配函数应为类成员函数或全局函数；如果分配函数在非全局范围的命名空间范围内声明，或在全局范围内声明为静态，则程序是格式错误的。\n')])])]),n("h2",{attrs:{id:"placement-new"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#placement-new"}},[t._v("#")]),t._v(" placement new")]),t._v(" "),n("ul",[n("li",[t._v("placement new 允许我们将object建构于allocated memory中。")]),t._v(" "),n("li",[t._v("没有placement delete，因为placement new根本没有分配memory")])]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("char* buf = new char[sizeof(Complex)*3];\nComplex* pc = new(buf)Complex(1, 2);\n//||编译器转为\nvoid* mem = operator new(sizeof(Complex), buf);//operator new(size_t,void* loc){return loc;}\npc = static_cast<Complex*>(mem);\npc->Complex::Complex(1, 2);\n")])])]),n("h2",{attrs:{id:"pre-class-allocator"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pre-class-allocator"}},[t._v("#")]),t._v(" pre-class allocator")]),t._v(" "),n("h3",{attrs:{id:"第一版"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第一版"}},[t._v("#")]),t._v(" 第一版")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Screen {\npublic:\n    Screen(int x) : i(x) { };\n    void* operator new(size_t);\n    void  operator delete(void*, size_t);\t    \nprivate:\n    Screen* next;\n    static Screen* freeStore;\n    static const int screenChunk;\nprivate:\n    int i;\n};\nScreen* Screen::freeStore = 0;\nconst int Screen::screenChunk = 24;\n\nvoid* Screen::operator new(size_t size)\n{\n  Screen *p;\n  if (!freeStore) {\n      //linked list 是空的，所以攫取一大塊 memory\n      //以下呼叫的是 global operator new\n      size_t chunk = screenChunk * size;\n      freeStore = p =\n         reinterpret_cast<Screen*>(new char[chunk]);\n      //將分配得來的一大塊 memory 當做 linked list 般小塊小塊串接起來\n      for (; p != &freeStore[screenChunk-1]; ++p)\n          p->next = p+1;\n      p->next = 0;\n  }\n  p = freeStore;\n  freeStore = freeStore->next;\n  return p;\n}\nvoid Screen::operator delete(void *p, size_t)\n{\n  //將 deleted object 收回插入 free list 前端\n  (static_cast<Screen*>(p))->next = freeStore;\n  freeStore = static_cast<Screen*>(p);\n}\n\nvoid test_per_class_allocator_1()\n{\t\n    size_t const N = 100;\n    Screen* p[N];\t\n\n   \tfor (int i=0; i< N; ++i)\n   \t     p[i] = new Screen(i);         \n\n   \tfor (int i=0; i< N; ++i)\n   \t     delete p[i];     \t\n}\n")])])]),n("h3",{attrs:{id:"第二版"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第二版"}},[t._v("#")]),t._v(" 第二版")]),t._v(" "),n("p",[t._v("没有使用多余的指针")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Airplane {   //支援 customized memory management\nprivate:\n  \tstruct AirplaneRep {\n    \tunsigned long miles;\n    \tchar type;\n  \t};\nprivate:\n  \tunion {\n    \tAirplaneRep rep;  //此針對 used object\n    \tAirplane* next;   //此針對 free list\n  \t};\npublic:\n  \tunsigned long getMiles() { return rep.miles; }\n  \tchar getType() { return rep.type; }\n  \tvoid set(unsigned long m, char t)\n  \t{\n     \trep.miles = m;\n     \trep.type = t;\n  \t}\npublic:\n  \tstatic void* operator new(size_t size);\n  \tstatic void  operator delete(void* deadObject, size_t size);\nprivate:\n  \tstatic const int BLOCK_SIZE;\n  \tstatic Airplane* headOfFreeList;\n};\n\nAirplane* Airplane::headOfFreeList;  \nconst int Airplane::BLOCK_SIZE = 512;   \n\nvoid* Airplane::operator new(size_t size)\n{\n  \t//如果大小錯誤，轉交給 ::operator new()\n  \tif (size != sizeof(Airplane))\n    \treturn ::operator new(size);\n\n  \tAirplane* p = headOfFreeList;  \n\n  \t//如果 p 有效，就把list頭部移往下一個元素\n  \tif (p)\n    \theadOfFreeList = p->next;\n  \telse {\n    \t//free list 已空。配置一塊夠大記憶體，\n    \t//令足夠容納 BLOCK_SIZE 個 Airplanes\n    \tAirplane* newBlock = static_cast<Airplane*>\n       \t\t(::operator new(BLOCK_SIZE * sizeof(Airplane)));\n    \t//組成一個新的 free list：將小區塊串在一起，但跳過 \n    \t//#0 元素，因為要將它傳回給呼叫者。\n    \tfor (int i = 1; i < BLOCK_SIZE-1; ++i)\n      \t\tnewBlock[i].next = &newBlock[i+1];\n    \tnewBlock[BLOCK_SIZE-1].next = 0; //以null結束\n\n    \t// 將 p 設至頭部，將 headOfFreeList 設至\n    \t// 下一個可被運用的小區塊。\n    \tp = newBlock;\n    \theadOfFreeList = &newBlock[1];\n  \t}\n  \treturn p;\n}\n\n// operator delete 接獲一塊記憶體。\n// 如果它的大小正確，就把它加到 free list 的前端\nvoid Airplane::operator delete(void* deadObject,\n                               size_t size)\n{\n  \tif (deadObject == 0) return;          \n  \tif (size != sizeof(Airplane)) {   \n    \t::operator delete(deadObject);\n    \treturn;\n  \t}\n\n  \tAirplane *carcass =\n    \tstatic_cast<Airplane*>(deadObject);\n\n  \tcarcass->next = headOfFreeList;\n  \theadOfFreeList = carcass;\n}\n\n//-------------\nvoid test_per_class_allocator_2() \n{\t\n  \tcout << sizeof(Airplane) << endl;    //8\n    size_t const N = 100;\n    Airplane* p[N];\t\n   \tfor (int i=0; i< N; ++i)\n   \t     p[i] = new Airplane;     \t\t\t\n  \t\n\t//輸出前 10 個 pointers, 用以比較其間隔 \n   \tfor (int i=0; i< 10; ++i)  \t   \n\t\tcout << p[i] << endl; \t\t \n\t \n   \tfor (int i=0; i< N; ++i)\n   \t     delete p[i]; \t\n}\n")])])]),n("h3",{attrs:{id:"第三版-static-allocator"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第三版-static-allocator"}},[t._v("#")]),t._v(" 第三版 static allocator")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class allocator \n{\nprivate:\n  \tstruct obj {\n    \tstruct obj* next;  //embedded pointer\n  \t};\t\npublic:\n    void* allocate(size_t);\n    void  deallocate(void*, size_t);\n    void  check();\n    \nprivate: \n    obj* freeStore = nullptr;\n    const int CHUNK = 5; //小一點方便觀察 \n};\n\nvoid* allocator::allocate(size_t size)\n{\n  \tobj* p;\n\n  \tif (!freeStore) {\n      \t//linked list 是空的，所以攫取一大塊 memory\n      \tsize_t chunk = CHUNK * size;\n      \tfreeStore = p = (obj*)malloc(chunk);  \n      \n      \t//cout << "empty. malloc: " << chunk << "  " << p << endl;\n     \n      \t//將分配得來的一大塊當做 linked list 般小塊小塊串接起來\n      \tfor (int i=0; i < (CHUNK-1); ++i)\t{  //沒寫很漂亮, 不是重點無所謂.  \n           \tp->next = (obj*)((char*)p + size);\n           \tp = p->next;\n      \t}\n      \tp->next = nullptr;  //last       \n  \t}\n  \tp = freeStore;\n  \tfreeStore = freeStore->next;\n   \n  \t//cout << "p= " << p << "  freeStore= " << freeStore << endl;\n  \n  \treturn p;\n}\nvoid allocator::deallocate(void* p, size_t)\n{\n  \t//將 deleted object 收回插入 free list 前端\n  \t((obj*)p)->next = freeStore;\n  \tfreeStore = (obj*)p;\n}\nvoid allocator::check()\n{ \n    obj* p = freeStore;\n    int count = 0;\n    \n    while (p) {\n        cout << p << endl;\n\t\tp = p->next;\n\t\tcount++;\n\t}\n    cout << count << endl;\n}\n\nclass Foo {\npublic: \n\tlong L;\n\tstring str;\n\tstatic allocator myAlloc;\npublic:\n\tFoo(long l) : L(l) {  }\n\tstatic void* operator new(size_t size)\n  \t{     return myAlloc.allocate(size);  \t}\n  \tstatic void  operator delete(void* pdead, size_t size)\n    {     return myAlloc.deallocate(pdead, size);  }\n};\nallocator Foo::myAlloc;\n')])])]),n("h3",{attrs:{id:"第四版-micro-for-static-allocator"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第四版-micro-for-static-allocator"}},[t._v("#")]),t._v(" 第四版 micro for static allocator")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// DECLARE_POOL_ALLOC -- used in class definition\n#define DECLARE_POOL_ALLOC() \\\npublic: \\\n    void* operator new(size_t size) { return myAlloc.allocate(size); } \\\n    void operator delete(void* p) { myAlloc.deallocate(p, 0); } \\\nprotected: \\\n    static allocator myAlloc; \n\n// IMPLEMENT_POOL_ALLOC -- used in class implementation file\n#define IMPLEMENT_POOL_ALLOC(class_name) \\\nallocator class_name::myAlloc; \n\n\n// in class definition file\nclass Foo {\n   DECLARE_POOL_ALLOC()\npublic: \n\tlong L;\n\tstring str;\npublic:\n\tFoo(long l) : L(l) {  }   \n};\n//in class implementation file\nIMPLEMENT_POOL_ALLOC(Foo) \n")])])]),n("p",[t._v("第二讲 std::allocator")]),t._v(" "),n("p",[t._v("第三讲 malloc/free")]),t._v(" "),n("p",[t._v("第四讲 other allocators")]),t._v(" "),n("p",[t._v("第五讲 loki::alloctor")])])}),[],!1,null,null,null);e.default=r.exports}}]);