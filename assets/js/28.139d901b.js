(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{462:function(t,e,n){"use strict";n.r(e);var s=n(46),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"mutex"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mutex"}},[t._v("#")]),t._v(" mutex")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("namespace std\n{\n    //mutex系列类\n    class mutex;//基本的mutex类\n    class recursive_mutex;//递归 mutex 类。\n    class timed_mutex;//定时 mutex 类。\n    class recursive_timed_mutex;//定时递归 mutex 类。\n\n    //其他类型\n    struct adopt_lock_t;\n    struct defer_lock_t;\n    struct try_to_lock_t;\n    struct once_flag;\n\n    constexpr adopt_lock_t adopt_lock{};\n    constexpr defer_lock_t defer_lock{};\n    constexpr try_to_lock_t try_to_lock{};\n\n    //lock类\n    template<typename LockableType>\n    class lock_guard;\n    template<typename LockableType>\n    class unique_lock;\n\n    //函数\n    template<typename LockableType1,typename... LockableType2>\n    void lock(LockableType1& m1,LockableType2& m2...);//同时对多个互斥量上锁。\n    template<typename LockableType1,typename... LockableType2>\n    int try_lock(LockableType1& m1,LockableType2& m2...);//尝试同时对多个互斥量上锁。\n    template<typename Callable,typename... Args>\n    void call_once(once_flag& flag,Callable func,Args args...);//如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。\n}\n")])])]),n("h3",{attrs:{id:"std-mutex类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-mutex类"}},[t._v("#")]),t._v(" std::mutex类")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class mutex\n{\npublic:\n  mutex(mutex const&)=delete;\n  mutex& operator=(mutex const&)=delete;\n\n  constexpr mutex() noexcept;\n  ~mutex();\n\n  void lock();\n  void unlock();\n  bool try_lock();\n};\n")])])]),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('#include <iostream> //std::cout\n#include <thread>   //std::thread\n#include <mutex>    //std::mutex\n#include <chrono>   //std::chrono\n\nvolatile int counter(0);        // non-atomic counter\nstd::mutex mtx;                 // locks access to counter\n\nvoid attempt_10k_increases() \n{\n    for (int i=0; i<100; ++i) \n    {\n        if (mtx.try_lock()) \n        {   // only increase if currently not locked:\n            ++counter;\n            std::this_thread::sleep_for(std::chrono::microseconds(50));\n            mtx.unlock();\n        }\n        else\n        {\n            std::cout << std::this_thread::get_id() << " failed" << std::endl;\n        }\n    }\n}\n\nint main (int argc, const char* argv[]) \n{\n    std::thread threads[10];\n    for (int i=0; i<10; ++i)\n    {\n        threads[i] = std::thread(attempt_10k_increases);\n    }\n\n    for (auto& th : threads) \n    {\n        th.join();\n    }\n    \n    std::cout << counter << " successful increases of the counter.\\n";\n\n    return 0;\n}\n')])])]),n("h3",{attrs:{id:"std-recursive-mutex类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-recursive-mutex类"}},[t._v("#")]),t._v(" std::recursive_mutex类")]),t._v(" "),n("p",[t._v("std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。")]),t._v(" "),n("h3",{attrs:{id:"std-timed-mutex类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-timed-mutex类"}},[t._v("#")]),t._v(" std::timed_mutex类")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class timed_mutex\n{\npublic:\n  timed_mutex(timed_mutex const&)=delete;\n  timed_mutex& operator=(timed_mutex const&)=delete;\n\n  timed_mutex();\n  ~timed_mutex();\n\n  void lock();\n  void unlock();\n  bool try_lock();\n\n  //在指定的relative_time时间内，尝试获取锁。\n  template<typename Rep,typename Period>\n  bool try_lock_for(std::chrono::duration<Rep,Period> const& relative_time);\n  //时间点 chrono::system_clock.now()+timeout\n  template<typename Clock,typename Duration>\n  bool try_lock_until(std::chrono::time_point<Clock,Duration> const& absolute_time);\n};\n")])])]),n("h3",{attrs:{id:"std-lock-guard类型模板"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-lock-guard类型模板"}},[t._v("#")]),t._v(" std::lock_guard类型模板")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("template <class Mutex>\nclass lock_guard\n{\npublic:\n  typedef Mutex mutex_type;\n\n  explicit lock_guard(mutex_type& m);\n  lock_guard(mutex_type& m, adopt_lock_t);\n  ~lock_guard();\n\n  lock_guard(lock_guard const& ) = delete;\n  lock_guard& operator=(lock_guard const& ) = delete;\n};\n")])])]),n("p",[t._v("指定的互斥量在构造函数中上锁，在析构函数中解锁。这就为互斥量锁部分代码提供了一个简单的方式；当程序运行完成时，阻塞解除，互斥量解锁(无论是执行到最后，还是通过控制流语句break或return，亦或是抛出异常)。")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('std::mutex g_mtx;\nvoid threadfunc(char ch)\n{\n    //首先，这在一个局部作用域内， std::lock_guard 在构造时，\n    //会调用 g_mutex->lock() 方法;\n    std::lock_guard<std::mutex> lock(g_mtx);    \n    for (int i = 0; i < 5; ++i)\n    {   \n        //std::lock_guard<std::mutex> lock(g_mtx);     //加锁\n        for (int j = 0; j < 5; ++j)\n        { // std::lock_guard<std::mutex> lock(g_mtx); \n            printf("i=%d,j=%d %c", i,j,ch);\n        }\n        printf("\\n");\n    }\n    printf("\\n");\n    //局部作用域代码结束后，\n    //std::lock_guard 的析构函数会被调用,\n    //函数中会调用 g_mutex->unlock() 方法。\n}\n\nint main()\n{\n    char ch = \'a\';\n    std::thread that[5];\n    for (int i = 0; i < 5; ++i)\n    {\n         that[i] = std::thread(threadfunc, ch + i);\n    }\n    for (int i = 0; i < 5; ++i)\n    {\n       that[i].join();\n    }\n   cout << "Main End" << endl;\n   return 0;\n}\n')])])]),n("h3",{attrs:{id:"std-unique-lock类型模板"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-unique-lock类型模板"}},[t._v("#")]),t._v(" std::unique_lock类型模板")]),t._v(" "),n("p",[t._v("临时加解锁")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("void shared_print(string msg, int id) {\n    std::unique_lock<std::mutex> guard(_mu, std::defer_lock);//延时加锁\n    //do something 1\n\n    guard.lock();\n    // do something protected\n    guard.unlock(); //临时解锁\n\n    //do something 2\n\n    guard.lock(); //继续上锁\n    // do something 3\n    f << msg << id << endl;\n    cout << msg << id << endl;\n    // 结束时析构guard会临时解锁\n}\n")])])]),n("p",[t._v("通过std::defer_lock设置初始化的时候不进行默认的上锁操作。在无需加锁的操作时，可以先临时释放锁，然后需要继续保护的时候，可以继续上锁，这样就无需重复的实例化lock_guard对象，还能减少锁的区域。")]),t._v(" "),n("h3",{attrs:{id:"std-lock函数模板"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-lock函数模板"}},[t._v("#")]),t._v(" std::lock函数模板")]),t._v(" "),n("p",[t._v("std::lock函数模板提供同时锁住多个互斥量的功能，且不会有因改变锁的一致性而导致的死锁。")]),t._v(" "),n("h3",{attrs:{id:"std-try-lock函数模板"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#std-try-lock函数模板"}},[t._v("#")]),t._v(" std::try_lock函数模板")]),t._v(" "),n("p",[t._v("std::try_lock函数模板允许尝试获取一组可锁对象上的锁，所以要不全部获取，要不一个都不获取。")]),t._v(" "),n("h3",{attrs:{id:"练习"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#练习"}},[t._v("#")]),t._v(" 练习")]),t._v(" "),n("p",[t._v("c++多线程中死锁多出现在使用多个mutex，而mutex的顺序不一样。比如下面的代码为了保证输出的原子性，在两个输出的函数中使用了两个mutex，但是这两个mutex锁的顺序是不一样的，结果就造成了死锁。")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('#include<iostream>\n#include<thread>\n#include<mutex>\n#include<string>\n#include<fstream>\n\nclass LofFile\n{\npublic:\n\n\tvoid share_print(std::string msg, int id) {\n\t\tstd::lock_guard<std::mutex> guard(m_mutex);\n\t\tstd::lock_guard<std::mutex> guard2(m_mutex2);\n\t\tstd::cout << msg << " " << id << std::endl;\n\t}\n\n\tvoid share_print_f(std::string msg, int id) {\n\t\tstd::lock_guard<std::mutex> guard(m_mutex2);\n\t\tstd::lock_guard<std::mutex> guard2(m_mutex);\n\t\tstd::cout << msg << " " << id << std::endl;\n\t}\nprivate:\n\tstd::mutex m_mutex;\n\tstd::mutex m_mutex2;\n};\n\nvoid fun1(LofFile& log)\n{\n\tfor (int i = 0; i < 50; i++)\n\t{\n\t\tlog.share_print("fun1 id", i);\n\t}\n}\n\nint main(int argc, char** argv)\n{\n\tLofFile log;\n\tstd::thread t1(fun1, std::ref(log));\n\tfor (int i = 0; i < 50; i++)\n\t{\n\t\tlog.share_print_f("main id", i);\n\t}\n\tif (t1.joinable()) {\n\t\tt1.join();\n\t}\n\treturn 0;\n}\n')])])]),n("p",[t._v("如何避免在C++中使用mutex出现死锁\n1、判断自己的代码是否需要多个mutex\n2、清楚了解自己调用的方法之类的是否也有使用mutex的情况\n3、使用标准库中的std::Lock(std::mutex,···)来设置mutex")]),t._v(" "),n("p",[t._v("如何使用std::Lock(std::mutex,···)")]),t._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class LofFile\n{\npublic:\n\n\tvoid share_print(std::string msg, int id) {\n\t\tstd::lock(m_mutex, m_mutex2);\n\t\tstd::lock_guard<std::mutex> guard(m_mutex,std::adopt_lock);\n\t\tstd::lock_guard<std::mutex> guard2(m_mutex2,std::adopt_lock);\n\t\tstd::cout << msg << " " << id << std::endl;\n\t}\n\n\tvoid share_print_f(std::string msg, int id) {\n\t\tstd::lock(m_mutex, m_mutex2);\n\t\tstd::lock_guard<std::mutex> guard(m_mutex2,std::adopt_lock);\n\t\tstd::lock_guard<std::mutex> guard2(m_mutex,std::adopt_lock);\n\t\tstd::cout << msg << " " << id << std::endl;\n\t}\nprivate:\n\tstd::mutex m_mutex;\n\tstd::mutex m_mutex2;\n};\n')])])]),n("p",[t._v("主要修改了两个地方\n调用std::lock_guard"),n("a",{attrs:{href:"std::mutex"}},[t._v("std::mutex")]),t._v(" 前先使用std::lock(std::mutex,···)，\n其次在std::lock_guard"),n("a",{attrs:{href:"std::mutex"}},[t._v("std::mutex")]),t._v(" 中加入std::adopt_lock参数")])])}),[],!1,null,null,null);e.default=a.exports}}]);