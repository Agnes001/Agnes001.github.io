(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{492:function(a,t,e){"use strict";e.r(t);var s=e(46),n=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"lambda-表达式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lambda-表达式"}},[a._v("#")]),a._v(" Lambda 表达式")]),a._v(" "),e("p",[a._v("Lambda 表达式的基本语法如下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("[捕获列表](参数列表) 限定修饰符[mutable(可选)] 异常属性 -> 返回类型 {\n    // 函数体\n}\n")])])]),e("p",[a._v("上面的语法规则除了 [捕获列表] 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去，返回值使用了一个 -> 的形式进行（我们在上一节前面的尾返回类型已经提到过这种写法了）。\n所谓捕获列表，其实可以理解为参数的一种类型，lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的，这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：")])])}),[],!1,null,null,null);t.default=n.exports}}]);