(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{496:function(t,_,a){"use strict";a.r(_);var v=a(46),s=Object(v.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("泛型编程的语言支持机制就是模板——参数化类型。")]),t._v(" "),a("h2",{attrs:{id:"_1-模板函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-模板函数"}},[t._v("#")]),t._v(" 1 模板函数")]),t._v(" "),a("p",[t._v("调用过程是，先将函数模板实例化为函数，然后再发生函数调用。")]),t._v(" "),a("h3",{attrs:{id:"_1-1-函数模板与函数重载"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-函数模板与函数重载"}},[t._v("#")]),t._v(" 1.1 函数模板与函数重载")]),t._v(" "),a("p",[t._v("普通函数会进行隐式的数据类型转换, 函数模板不提供隐式的数据类型转换，必须是严格的匹配。")]),t._v(" "),a("ol",[a("li",[t._v("当函数模板和普通函数都符合调用时,优先选择普通函数")]),t._v(" "),a("li",[t._v("若显示使用函数模板,则使用<> 类型列表")]),t._v(" "),a("li",[t._v("如果函数模板产生更好的匹配,使用函数模板")])]),t._v(" "),a("h3",{attrs:{id:"_1-2-编译器对模板机制剖析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-编译器对模板机制剖析"}},[t._v("#")]),t._v(" 1.2 编译器对模板机制剖析")]),t._v(" "),a("ol",[a("li",[t._v("编译器并不是把函数模板处理成能够处理任意类的函数")]),t._v(" "),a("li",[t._v("编译器从函数模板通过具体类型产生不同的函数")]),t._v(" "),a("li",[t._v("编译器会对函数模板进行两次编译,在声明的地方对模板代码本身进行编译；在调用的地方对参数替换后的代码进行编译。")])]),t._v(" "),a("h2",{attrs:{id:"_2-模板类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-模板类"}},[t._v("#")]),t._v(" 2 模板类")]),t._v(" "),a("p",[t._v("模板类派生普通类\n子类从模板类继承的时候，需要让编译器知道父类的数据类型具体是什么(数据类型的本质：固定大小内存块的别名)")]),t._v(" "),a("p",[t._v("模板类派生模板类\n无需指定模板T类型")]),t._v(" "),a("p",[t._v("实现模板方法建议在同一个文件.h中完成")])])}),[],!1,null,null,null);_.default=s.exports}}]);