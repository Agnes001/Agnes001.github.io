(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{482:function(t,n,e){"use strict";e.r(n);var c=e(46),i=Object(c.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("atomic对int、char、bool等数据结构进行了原子性封装，在多线程环境中，对std::atomic对象的访问不会造成竞争-冒险。利用std::atomic可实现数据结构的无锁设计。")]),t._v(" "),e("p",[t._v("所谓的原子操作，取的就是“原子是最小的、不可分割的最小个体”的意义，它表示在多个线程访问同一个全局资源的时候，能够确保所有其他的线程都不在同一时间内访问相同的资源。也就是他确保了在同一时刻只有唯一的线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高。")]),t._v(" "),e("p",[t._v("在以往的C++标准中并没有对原子操作进行规定，我们往往是使用汇编语言，或者是借助第三方的线程库，例如intel的pthread来实现。在新标准C++11，引入了原子操作的概念，并通过这个新的头文件提供了多种原子操作数据类型，例如，atomic_bool,atomic_int等等，如果我们在多个线程中对这些类型的共享资源进行操作，编译器将保证这些操作都是原子性的，也就是说，确保任意时刻只有一个线程对这个资源进行访问，编译器将保证，多个线程访问这个共享资源的正确性。从而避免了锁的使用，提高了效率。")]),t._v(" "),e("p",[t._v("atomic高效体现\n加锁不使用atomic：")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('#include <iostream>\n#include <ctime>\n#include <mutex>\n#include <vector>\n#include <thread>\n \nstd::mutex mtx;\nsize_t count = 0;\n \nvoid threadFun()\n{\n\tfor (int i = 0; i < 10000; i++)\n\t{\n\t\t// 防止多个线程同时访问同一资源\n\t\tstd::unique_lock<std::mutex> lock(mtx);\n\t\tcount++;\n\t}\n}\n \nint main(void)\n{\n\tclock_t start_time = clock();\n \n\t// 启动多个线程\n\tstd::vector<std::thread> threads;\n\tfor (int i = 0; i < 10; i++)\n\t\tthreads.push_back(std::thread(threadFun));\n\tfor (auto&thad : threads)\n\t\tthad.join();\n \n\t// 检测count是否正确 10000*10 = 100000\n\tstd::cout << "count number:" << count << std::endl;\n \n\tclock_t end_time = clock();\n\tstd::cout << "耗时：" << end_time - start_time << "ms" << std::endl;\n \n\treturn 0;\n}\n')])])]),e("p",[t._v("使用atomic：")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('#include <iostream>\n#include <ctime>\n#include <vector>\n#include <thread>\n#include <atomic>\n \n \nstd::atomic<size_t> count(0);\n \nvoid threadFun()\n{\n\tfor (int i = 0; i < 10000; i++)\n\t\tcount++;\n}\n \nint main(void)\n{\n\tclock_t start_time = clock();\n \n\t// 启动多个线程\n\tstd::vector<std::thread> threads;\n\tfor (int i = 0; i < 10; i++)\n\t\tthreads.push_back(std::thread(threadFun));\n\tfor (auto&thad : threads)\n\t\tthad.join();\n \n\t// 检测count是否正确 10000*10 = 100000\n\tstd::cout << "count number:" << count << std::endl;\n \n\tclock_t end_time = clock();\n\tstd::cout << "耗时：" << end_time - start_time << "ms" << std::endl;\n \n\treturn 0;\n}\n')])])]),e("p",[t._v("第一个程序用时2439ms，第二个程序用时13ms，使用原子操作能大大的提高程序的运行效率。")])])}),[],!1,null,null,null);n.default=i.exports}}]);