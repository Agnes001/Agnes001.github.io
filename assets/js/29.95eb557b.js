(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{484:function(n,t,i){"use strict";i.r(t);var e=i(46),a=Object(e.a)({},(function(){var n=this,t=n.$createElement,i=n._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[i("h2",{attrs:{id:"condition-variable"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#condition-variable"}},[n._v("#")]),n._v(" condition_variable")]),n._v(" "),i("p",[n._v("<condition_variable>头文件提供了条件变量的定义。其作为基本同步机制，允许被阻塞的线程在某些条件达成或超时时，解除阻塞继续执行。")]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("namespace std\n{\n  enum class cv_status { timeout, no_timeout };\n\n  class condition_variable;\n  class condition_variable_any;\n}\n")])])]),i("h3",{attrs:{id:"std-condition-variable类"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#std-condition-variable类"}},[n._v("#")]),n._v(" std::condition_variable类")]),n._v(" "),i("p",[n._v("std::condition_variable 允许阻塞一个线程，直到条件达成。")]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('#include<iostream>\n#include<thread>\n#include<mutex>\n#include<condition_variable>\nstd::mutex mtx;\nstd::condition_variable cv;\nbool ready = false;   // 全局标志位\n\nvoid printId(int id)\n{\n  std::unique_lock<std::mutex> lck(mtx);\n  // 如果标志位不为true，则等待\n  while(!ready)\n  {\n    // 线程被阻塞，直到标志位变为true\n    cv.wait(lck);\n  }\n  std::cout << "thread: " << std::this_thread::get_id() << " id: " << id << "\\n";\n}\n\nvoid go()\n{\n  std::unique_lock<std::mutex> lck(mtx);\n  // 改变全局标志位\n  ready = true;\n  // 唤醒所有线程\n  cv.notify_all();\n}\n\nint main()\n{\n  std::thread threads[10];\n\n  for (int i = 0; i < 10; ++i)\n  {\n    threads[i] = std::thread(printId, i);\n  }\n  std::cout << "create done.\\n" ;\n\n  go();\n\n  for (auto &t : threads)\n  {\n    t.join();\n  }\n  std::cout << "process done.\\n" ;\n  return 0;\n\n//输出：\ncreate done.\nthread: 140496261539584 id: 0\nthread: 140496253146880 id: 1\nthread: 140496244754176 id: 2\nthread: 140496227968768 id: 4\nthread: 140496211183360 id: 6\nthread: 140496194397952 id: 8\nthread: 140496202790656 id: 7\nthread: 140496186005248 id: 9\nthread: 140496219576064 id: 5\nthread: 140496236361472 id: 3\nprocess done.\n')])])]),i("blockquote",[i("p",[n._v("wait 操作\nstd::condition_variable 提供了两种 wait() 函数。")])]),n._v(" "),i("ul",[i("li",[i("p",[n._v("无条件等待\nvoid wait (unique_lock"),i("mutex",[n._v("& lck);\n当前线程调用 wait() 后将被阻塞（此时当前线程应该获得了锁（mutex），不妨设获得锁 lck），直到另外某个线程调用 notify_* 唤醒了当前线程。在线程被阻塞时（也就是调用 wait() 的时候），该函数会自动调用 lck.unlock() 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。另外，一旦当前线程获得通知（notified，通常是另外某个线程调用 notify_* 唤醒了当前线程），wait() 函数也是自动调用 lck.lock()，使得 lck 的状态和 wait 函数被调用时相同。")])],1)]),n._v(" "),i("li",[i("p",[n._v("有条件等待\ntemplate "),i("class",{attrs:{Predicate:""}},[n._v("\nvoid wait (unique_lock"),i("mutex",[n._v("& lck, Predicate pred);\n第二种情况设置了 Predicate，只有当 pred 条件为 false 时调用 wait() 才会阻塞当前线程，并且在收到其他线程的通知后只有当 pred 为 true 时才会被解除阻塞。因此第二种情况类似以下代码：")])],1)],1)])]),n._v(" "),i("p",[n._v("while (!pred())\n{\nwait(lck);\n}\n和 mutex 的 lock 类似，std::condition_variable 也提供了相应的两种（带 Predicate 和不带 Predicate） wait_for() 函数，与 std::condition_variable::wait() 类似，不过 wait_for 可以指定一个时间段，在当前线程收到通知或者指定的时间超时之前，该线程都会处于阻塞状态。而一旦超时或者收到了其他线程的通知，wait_for 返回，剩下的处理步骤和 wait() 类似。还有 wait_util()，用法也类似。")]),n._v(" "),i("blockquote",[i("p",[n._v("notify 操作")])]),n._v(" "),i("ul",[i("li",[i("p",[n._v("std::condition_variable::notify_one()\n唤醒某个等待（wait）线程。如果当前没有等待线程，则该函数什么也不做，如果同时存在多个等待线程，则唤醒某个线程是不确定的（unspecified）。")])]),n._v(" "),i("li",[i("p",[n._v("std::condition_variable::notify_all()\n唤醒所有的等待（wait）线程。如果当前没有等待线程，则该函数什么也不做。")])])]),n._v(" "),i("p",[n._v("非常好文：https://blog.csdn.net/KingOfMyHeart/article/details/118076229")]),n._v(" "),i("h3",{attrs:{id:"std-condition-variable-any类"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#std-condition-variable-any类"}},[n._v("#")]),n._v(" std::condition_variable_any类")]),n._v(" "),i("p",[n._v("与 std::condition_variable 类似，只不过 std::condition_variable_any 的 wait 函数可以接受任何 lockable 参数，而 std::condition_variable 只能接受 std::unique_lock"),i("a",{attrs:{href:"std::mutex"}},[n._v("std::mutex")]),n._v(" 类型的参数，除此以外，和 std::condition_variable 几乎完全一样。")]),n._v(" "),i("div",{staticClass:"language-c++ extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v('int main()\n{\n  std::queue<int> production;\n  std::mutex mtx;\n  std::condition_variable cv;\n  bool ready = false;  // 是否有产品可供消费\n  bool done = false;   // 生产结束\n\n  std::thread producer(\n    [&] () -> void {\n      for (int i = 1; i < 10; ++i)\n      {\n        // 模拟实际生产过程\n        std::this_thread ::sleep_for(std::chrono::milliseconds(10));\n        std::cout << "producing " << i << std::endl;\n\n        std::unique_lock<std::mutex> lock(mtx);\n        production.push(i);\n\n        // 有产品可以消费了\n        ready = true;\n        cv.notify_one();\n      }\n      // 生产结束了\n      done = true;\n    }\n  );\n\n  std::thread consumer(\n    [&] () -> void {\n      std::unique_lock<std::mutex> lock(mtx);\n      // 如果生成没有结束或者队列中还有产品没有消费，则继续消费，否则结束消费\n      while(!done || !production.empty())\n      {\n        // 防止误唤醒\n        while(!ready)\n        {\n          cv.wait(lock);\n        }\n\n        while(!production.empty())\n        {\n          // 模拟消费过程\n          std::cout << "consuming " << production.front() << std::endl;\n          production.pop();\n        }\n\n        // 没有产品了\n        ready = false;\n      }\n    }\n  );\n\n  producer.join();\n  consumer.join();\n\n  return 0;\n}\n')])])])])}),[],!1,null,null,null);t.default=a.exports}}]);