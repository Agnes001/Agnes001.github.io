(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{467:function(t,s,e){"use strict";e.r(s);var a=e(46),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"c-对c语言的加强和扩展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#c-对c语言的加强和扩展"}},[t._v("#")]),t._v(" C++对C语言的加强和扩展")]),t._v(" "),e("h3",{attrs:{id:"const增强-c-中由const修饰的是一个真正的常量"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#const增强-c-中由const修饰的是一个真正的常量"}},[t._v("#")]),t._v(" const增强-C++中由const修饰的是一个真正的常量")]),t._v(" "),e("ol",[e("li",[t._v("在C语言中，const常量可通过指针进行修改，因为C语言中的const常量有自己的存储空间。")]),t._v(" "),e("li",[t._v("C++中，会将常量放在符号表中，如果对常量取地址或者extern操作，编译器会临时开辟一个空间temp，让这个指针存放这个临时空间的地址。")])]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 如下定义在C++中是允许的，在C语言中出错\nconst int\ta\t=\t1;\t\t\t\nconst int\tb\t=\t2;\t\t\t\nint\tarray[a+b]\t=\t{0};\n")])])]),e("ol",{attrs:{start:"3"}},[e("li",[t._v("const和#define的区别")])]),t._v(" "),e("ul",[e("li",[t._v("C++中的const常量类似于宏定义"),e("br"),t._v("\nconst int c = 5; ≈ #define c 5")]),t._v(" "),e("li",[t._v("C++中的const常量与宏定义不同"),e("br"),t._v("\nconst常量是由编译器处理的，提供类型检查和作用域检查"),e("br"),t._v("\n宏定义由预处理器处理，单纯的文本替换")])]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[t._v("C语言中的const变量 \n    C语言中const变量是只读变量，有自己的存储空间\nC++中的const常量 \n    可能分配存储空间,也可能不分配存储空间 \n    当const常量为全局，并且需要在其它文件中使用，会分配存储空间 \n    当使用"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("操作符，取const常量的地址时，会分配存储空间 \n    当const int "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("a "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" const修饰引用时，也会分配存储空间\n")])])]),e("h2",{attrs:{id:"类与类的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类与类的关系"}},[t._v("#")]),t._v(" 类与类的关系")]),t._v(" "),e("h3",{attrs:{id:"复合-composition-表示has-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#复合-composition-表示has-a"}},[t._v("#")]),t._v(" 复合 (composition) 表示has-a")]),t._v(" "),e("p",[t._v("类中包含另一个类的对象，所占空间累加在当前对象上")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("template <class T, class Sequence = deque<T>>\nclass queue {\n...\nprotected:\nSequence c; // 底層容器\npublic:\n// 以下完全利用 c 的操作函數完成\nbool empty() const { return c.empty(); }\nsize_type size() const { return c.size(); }\nreference front() { return c.front(); }\nreference back() { return c.back(); }\n// deque 是兩端可進出，queue 是末端進前端出（先進先出）\nvoid push(const value_type& x) { c.push_back(x); }\nvoid pop() { c.pop_front(); }\n};\n")])])]),e("p",[t._v("构造由内而外，析构由外而内：构造时先调用里边对象的构造函数，然后再调用当前类的构造函数，析构时正好相反。")]),t._v(" "),e("h3",{attrs:{id:"委托-delegation-表示composition-by-reference"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#委托-delegation-表示composition-by-reference"}},[t._v("#")]),t._v(" 委托 (delegation) 表示composition by reference")]),t._v(" "),e("p",[t._v("类内含有另一个类的指针。")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class StringRep;\nclass String\n{\npublic:\n\t... // 一些公有接口\nprivate:\n\tStringRep* rep; //类内含有类的指针\n}\n\nclass StringRep{...};\n")])])]),e("p",[e("strong",[t._v("复合与委托的区别")])]),t._v(" "),e("ul",[e("li",[t._v("复合生命是一起出现的，有queue对象就有了deque对象。")]),t._v(" "),e("li",[t._v("而委托，类内含有指针，只有需要用到类指针的时候才会有指向的实现类，不同步。")])]),t._v(" "),e("h3",{attrs:{id:"继承-inheritance-表示-is-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#继承-inheritance-表示-is-a"}},[t._v("#")]),t._v(" 继承（inheritance） 表示 is-a")]),t._v(" "),e("p",[t._v("父类和派生类被称为继承。")]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("class _List_node_base{...}; // base class \n\nclass _Lisr_node: public _List_node_base {...} // derived class \n")])])]),e("p",[t._v("注意事项：")]),t._v(" "),e("ul",[e("li",[t._v("父类的析构函数必须是virtual，否则会出现undefined behavior")]),t._v(" "),e("li",[t._v("构造由内向外，先执行父类的构造函数，然后才执行自己。")]),t._v(" "),e("li",[t._v("析构由外向内，先执行自己的析构函数，然后执行父类的构造函数。")])]),t._v(" "),e("p",[e("strong",[t._v("inheritance with virtual functions(虚函数)")])]),t._v(" "),e("ol",[e("li",[t._v("non-virtual函数 : 不希望derived class重新定义(override)它。")]),t._v(" "),e("li",[t._v("virtual函数 : 希望derived class重新定义(override,覆盖)它，父类中含有默认定义。")]),t._v(" "),e("li",[t._v("pure virtual函数 : derived class必须重新定义。")])]),t._v(" "),e("div",{staticClass:"language-c++ extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("int getID() const;\nvirtual void error(string& str);\nvirtual void draw() = 0;\n")])])]),e("p",[e("strong",[t._v("继承中同名成员变量处理方法")]),e("br"),t._v("\n1、当子类成员变量与父类成员变量同名时"),e("br"),t._v("\n2、子类依然从父类继承同名成员"),e("br"),t._v("\n3、在子类中通过作用域分辨符::进行同名成员区分（在派生类中使用基类的同名成员，显式地使用类名限定符）"),e("br"),t._v("\n4、同名成员存储在内存中的不同位置")]),t._v(" "),e("p",[e("strong",[t._v("虚继承virtual")]),e("br"),t._v("\n1、如果一个派生类从多个基类派生，而这些基类又有一个共同的基类，则在对该基类中声明的名字进行访问时，可能产生二义性"),e("br"),t._v("\n2、如果在多条继承路径上有一个公共的基类，那么在继承路径的某处汇合点，这个公共基类就会在派生类的对象中产生多个基类子对象"),e("br"),t._v("\n3、要使这个公共基类在派生类中只产生一个子对象，必须对这个基类声明为虚继承，使这个基类成为虚基类。"),e("br"),t._v("\n4、虚继承声明使用关键字 virtual")])])}),[],!1,null,null,null);s.default=n.exports}}]);