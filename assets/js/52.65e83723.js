(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{454:function(n,a,t){"use strict";t.r(a);var e=t(46),r=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"创建型模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建型模型"}},[n._v("#")]),n._v(" 创建型模型")]),n._v(" "),t("h2",{attrs:{id:"简单工厂模式-不属于gof设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单工厂模式-不属于gof设计模式"}},[n._v("#")]),n._v(" 简单工厂模式 不属于GoF设计模式")]),n._v(" "),t("ul",[t("li",[n._v("工厂（Factory）角色：简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。")]),n._v(" "),t("li",[n._v("抽象产品（Abstract Product）角色：简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。")]),n._v(" "),t("li",[n._v("具体产品（Concrete Product）角色：简单工厂模式所创建的具体实例对象。")])]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<string>\nusing namespace std;\n//抽象水果\nclass Fruit{\npublic:\nvirtual void shoName() = 0;\n};\n//苹果类\nclass Apple : public Fruit{\npublic:\nvirtual void shoName(){\ncout << "我是苹果" << endl;\n}\n};\n//香蕉类\nclass Banana : public Fruit{\npublic:\nvirtual void shoName(){\ncout << "我是香蕉" << endl;\n}\n};\n//鸭梨类\nclass Pear : public Fruit{\npublic:\nvirtual void shoName(){\ncout << "我是鸭梨" << endl;\n}\n};\n//水果工厂\nclass FruitFactory{\npublic:\nstatic Fruit* CreateFruit(string name){\nif (name.compare("apple") == 0){\nreturn new Apple; }\nelse if (name.compare("banana") == 0){\nreturn new Banana; }\nelse if (name.compare("pear") == 0){\nreturn new Pear; } }\n};\n//测试\nvoid test01(){\nFruit* fruit = NULL;\nfruit = FruitFactory::CreateFruit("apple"); //工厂生产苹果\nfruit->shoName();\ndelete fruit;\nfruit = FruitFactory::CreateFruit("banana"); //工厂生产香蕉\nfruit->shoName();\ndelete fruit;\nfruit = FruitFactory::CreateFruit("pear"); //工厂生产鸭梨\nfruit->shoName();\ndelete fruit;\n}\nint main(){\n    test01();\n    system("pause");\n    return EXIT_SUCCESS; \n}\n')])])]),t("h3",{attrs:{id:"简单工厂模式的优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单工厂模式的优缺点"}},[n._v("#")]),n._v(" 简单工厂模式的优缺点")]),n._v(" "),t("p",[n._v("优点："),t("br"),n._v("\n(1)实现了对象创建和使用的分离。"),t("br"),n._v("\n(2)不需要记住具体类名，记住参数即可，减少使用者记忆量。"),t("br"),n._v("\n缺点："),t("br"),n._v("\n(1)对工厂类职责过重，一旦不能工作，系统受到影响。"),t("br"),n._v("\n(2)增加系统中类的个数，复杂度和理解度增加。"),t("br"),n._v("\n(3)违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂。")]),n._v(" "),t("h2",{attrs:{id:"工厂方法模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工厂方法模式"}},[n._v("#")]),n._v(" 工厂方法模式")]),n._v(" "),t("p",[n._v("工厂方法(Factory Method)模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。")]),n._v(" "),t("ul",[t("li",[n._v("抽象工厂（Abstract Factory）角色：工厂方法模式的核心，任何工厂类都必须实现这个接口。")]),n._v(" "),t("li",[n._v("工厂（Concrete Factory）角色：具体工厂类是抽象工厂的一个实现，负责实例化产品对象。")]),n._v(" "),t("li",[n._v("抽象产品（Abstract Product）角色：工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。")]),n._v(" "),t("li",[n._v("具体产品（Concrete Product）角色：工厂方法模式所创建的具体实例对象。")]),n._v(" "),t("li",[n._v("简单工厂模式 + “开闭原则” = 工厂方法模式")])]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\nusing namespace std;\n//抽象水果\nclass AbstractFruit{\npublic:\nvirtual void showName() = 0;\n};\n/* 具体水果 start */\n//苹果\nclass Apple : public AbstractFruit{\npublic:\nvirtual void showName(){\ncout << "我是苹果" << endl;\n}\n};\n//香蕉\nclass Banana : public AbstractFruit{\npublic:\nvirtual void showName(){\ncout << "我是香蕉" << endl;\n}\n};\n//鸭梨\nclass Pear : public AbstractFruit{\npublic:\nvirtual void showName(){\ncout << "我是鸭梨" << endl;\n}\n};\n/* 具体水果 end */\n//抽象工厂\nclass AbstractFactory{\npublic:\nvirtual AbstractFruit* CreateFruit() = 0;\n};\n/* 具体工厂类 start */\n//苹果工厂\nclass AppleFactory : public AbstractFactory{\npublic:\nvirtual AbstractFruit* CreateFruit(){\nreturn new Apple; }\n};\n//香蕉工厂\nclass BananaFactory : public AbstractFactory{\npublic:\nvirtual AbstractFruit* CreateFruit(){\nreturn new Banana; }\n};\n//鸭梨工厂\nclass PearFactory : public AbstractFactory{\npublic:\nvirtual AbstractFruit* CreateFruit(){\nreturn new Pear; }\n};\n/* 具体工厂类 end */\n//测试\nvoid test01(){\nAbstractFactory* factory = NULL;\nAbstractFruit* fruit = NULL;\nfactory = new AppleFactory; //创建苹果工厂\nfruit = factory->CreateFruit(); //苹果工厂生产苹果\nfruit->showName();\nfactory = new BananaFactory; //创建香蕉工厂\nfruit = factory->CreateFruit(); //香蕉工厂生产苹果\nfruit->showName();\nfactory = new PearFactory; //创建鸭梨工厂\nfruit = factory->CreateFruit(); //鸭梨工厂生产苹果\nfruit->showName();\n}\nint main(){\ntest01();\nsystem("pause");\nreturn EXIT_SUCCESS; }\n')])])]),t("h3",{attrs:{id:"简单描述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单描述"}},[n._v("#")]),n._v(" 简单描述")]),n._v(" "),t("ol",[t("li",[n._v("给我来一个香蕉工厂")]),n._v(" "),t("li",[n._v("给我来一个水果")]),n._v(" "),t("li",[n._v("香蕉生产器只能生产具体的香蕉。")])]),n._v(" "),t("h3",{attrs:{id:"工厂方法模式的优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工厂方法模式的优缺点"}},[n._v("#")]),n._v(" 工厂方法模式的优缺点")]),n._v(" "),t("p",[n._v("优点："),t("br"),n._v("\n(1)不需要记住具体类名，甚至连具体参数都不用记忆。"),t("br"),n._v("\n(2)实现了对象创建和使用的分离。"),t("br"),n._v("\n(3)系统的可扩展性也就变得非常好，无需修改接口和原类。"),t("br"),n._v("\n缺点："),t("br"),n._v("\n(1)增加系统中类的个数，复杂度和理解度增加。"),t("br"),n._v("\n(2)增加了系统的抽象性和理解难度。")]),n._v(" "),t("h2",{attrs:{id:"抽象工厂模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象工厂模式"}},[n._v("#")]),n._v(" 抽象工厂模式")]),n._v(" "),t("p",[n._v("工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族，由同一个工厂来统一生产，这就是我们本文将要学习的抽象工厂模式的基本思想。")]),n._v(" "),t("ul",[t("li",[n._v("抽象工厂（Abstract Factory）角色：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。")]),n._v(" "),t("li",[n._v("具体工厂（Concrete Factory）角色：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。")]),n._v(" "),t("li",[n._v("抽象产品（Abstract Product）角色：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。")]),n._v(" "),t("li",[n._v("具体产品（Concrete Product）角色：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。")])]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\nusing namespace std;\n//抽象苹果类\nclass AbstractApple{\npublic:\nvirtual void showName() = 0;\n};\n//抽象香蕉\nclass AbstractBanana{\npublic:\nvirtual void showName() = 0;\n};\n//抽象鸭梨\nclass AbstractPear{\npublic:\nvirtual void showName() = 0;\n};\n//中国苹果\nclass ChineseApple : public AbstractApple{\npublic:\nvirtual void showName(){\ncout << "中国苹果" << endl;\n}\n};\n//美国苹果\nclass AmericanApple : public AbstractApple{\npublic:\nvirtual void showName(){\ncout << "美国苹果" << endl;\n}\n};\n//日本苹果\nclass JapaneseApple : public AbstractApple{\npublic:\nvirtual void showName(){\ncout << "日本苹果" << endl;\n}\n};\n//中国香蕉\nclass ChineseBanana : public AbstractBanana{\npublic:\nvirtual void showName(){\ncout << "中国香蕉" << endl;\n}\n};\n//美国香蕉\nclass AmericanBanana : public AbstractBanana{\npublic:\nvirtual void showName(){\ncout << "美国香蕉" << endl;\n}\n};\n//日本香蕉\nclass JapaneseBanana : public AbstractBanana{\npublic:\nvirtual void showName(){\ncout << "日本香蕉" << endl;\n}\n};\n//中国鸭梨\nclass ChinesePear : public AbstractPear{\npublic:\nvirtual void showName(){\ncout << "中国鸭梨" << endl;\n}\n};\n//美国鸭梨\nclass AmericanPear : public AbstractPear{\npublic:\nvirtual void showName(){\ncout << "美国鸭梨" << endl;\n}\n};\n//日本鸭梨\nclass JapanesePear : public AbstractPear{\npublic:\nvirtual void showName(){\ncout << "日本鸭梨" << endl;\n}\n};\n//抽象工厂\nclass AbstractFactory{\npublic:\nvirtual AbstractApple* CreateApple() = 0;\nvirtual AbstractBanana* CreateBanana() = 0;\nvirtual AbstractPear* CreatePear() = 0;\n};\n//中国工厂\nclass ChineseFactory : public AbstractFactory{\npublic:\nvirtual AbstractApple* CreateApple(){\nreturn new ChineseApple; }\nvirtual AbstractBanana* CreateBanana(){\nreturn new ChineseBanana; }\nvirtual AbstractPear* CreatePear(){\nreturn new ChinesePear; }\n};\n//美国工厂\nclass AmericanFactory : public AbstractFactory{\npublic:\nvirtual AbstractApple* CreateApple(){\nreturn new AmericanApple; }\nvirtual AbstractBanana* CreateBanana(){\nreturn new AmericanBanana; }\nvirtual AbstractPear* CreatePear(){\nreturn new AmericanPear; }\n};\n//美国工厂\nclass JapaneseFactory : public AbstractFactory{\npublic:\nvirtual AbstractApple* CreateApple(){\nreturn new JapaneseApple;\n}\nvirtual AbstractBanana* CreateBanana(){\nreturn new JapaneseBanana; }\nvirtual AbstractPear* CreatePear(){\nreturn new JapanesePear; }\n};\nvoid test01(){\nAbstractFactory* factory = NULL;\nAbstractApple* apple = NULL;\nAbstractBanana* banana = NULL;\nAbstractPear* pear = NULL;\nfactory = new ChineseFactory; //创建中国工厂\napple = factory->CreateApple();\nbanana = factory->CreateBanana();\npear = factory->CreatePear();\napple->showName();\nbanana->showName();\npear->showName();\ndelete pear;\ndelete banana;\ndelete apple;\ndelete factory;\nfactory = new AmericanFactory; //创建美国工厂\napple = factory->CreateApple();\nbanana = factory->CreateBanana();\npear = factory->CreatePear();\napple->showName();\nbanana->showName();\npear->showName();\ndelete pear;\ndelete banana;\ndelete apple;\ndelete factory;\nfactory = new JapaneseFactory; //创建日本工厂\napple = factory->CreateApple();\nbanana = factory->CreateBanana();\npear = factory->CreatePear();\napple->showName();\nbanana->showName();\npear->showName();\ndelete pear;\ndelete banana;\ndelete apple;\ndelete factory;\n}\nint main(){\ntest01();\nsystem("pause");\nreturn EXIT_SUCCESS; }\n')])])]),t("h3",{attrs:{id:"简单描述-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简单描述-2"}},[n._v("#")]),n._v(" 简单描述")]),n._v(" "),t("ol",[t("li",[n._v("给来一个美国的工厂")]),n._v(" "),t("li",[n._v("再给我来一个鸭梨")])]),n._v(" "),t("h3",{attrs:{id:"抽象工厂模式的优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象工厂模式的优缺点"}},[n._v("#")]),n._v(" 抽象工厂模式的优缺点")]),n._v(" "),t("p",[n._v("优点："),t("br"),n._v("\n(1)拥有工厂方法模式的优点"),t("br"),n._v("\n(2)当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。"),t("br"),n._v("\n(3)增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。"),t("br"),n._v("\n缺点："),t("br"),n._v("\n增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。")]),n._v(" "),t("h2",{attrs:{id:"单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[n._v("#")]),n._v(" 单例模式")]),n._v(" "),t("p",[n._v("单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。")]),n._v(" "),t("p",[n._v("Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的 getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个 Singleton类型的静态对象，作为外部共享的唯一实例。")]),n._v(" "),t("blockquote",[t("p",[n._v("如何构建单例:"),t("br"),n._v("\n一是单例模式的类只提供私有的构造函数，"),t("br"),n._v("\n二是类定义中含有一个该类的静态私有对象，"),t("br"),n._v("\n三是该类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。")])]),n._v(" "),t("h3",{attrs:{id:"懒汉式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#懒汉式"}},[n._v("#")]),n._v(" 懒汉式")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class Singleton_lazy{\nprivate:\n\tSingleton_lazy(){}\npublic:\n\tstatic Singleton_lazy* getInstance(){\n\t\tif (pSingleton == NULL){\n\t\t\tpSingleton = new Singleton_lazy;\n\t\t}\n\t\treturn pSingleton;\n\t}\nprivate:\n\tstatic Singleton_lazy* pSingleton;\n};\n//类外初始化\nSingleton_lazy* Singleton_lazy::pSingleton = NULL;\n")])])]),t("h3",{attrs:{id:"饿汉式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#饿汉式"}},[n._v("#")]),n._v(" 饿汉式")]),n._v(" "),t("div",{staticClass:"language-c++ extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class Singleton_hungry{\nprivate:\n\tSingleton_hungry(){}\npublic:\n\tstatic Singleton_hungry* getInstance(){\n\t\treturn pSingleton;\n\t}\n\tclass Garbo{\n\t\t~Garbo(){\n\t\t\tif (pSingleton != NULL){\n\t\t\t\tdelete pSingleton;\n\t\t\t}\n\t\t}\n\t};\n\nprivate:\n\tstatic Singleton_hungry* pSingleton;\n\tstatic Garbo garbo;\n}; \nSingleton_hungry* Singleton_hungry::pSingleton = new Singleton_hungry;\n")])])]),t("h3",{attrs:{id:"单例模式的优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单例模式的优缺点"}},[n._v("#")]),n._v(" 单例模式的优缺点")]),n._v(" "),t("p",[n._v("优点:"),t("br"),n._v("\n(1)单例模式提供了对唯一实例的受控访问。"),t("br"),n._v("\n(2)节约系统资源。由于在系统内存中只存在一个对象。"),t("br"),n._v("\n缺点:"),t("br"),n._v("\n(1) 扩展略难。单例模式中没有抽象层。"),t("br"),n._v("\n(2) 单例类的职责过重。")]),n._v(" "),t("h1",{attrs:{id:"结构型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构型模式"}},[n._v("#")]),n._v(" 结构型模式")]),n._v(" "),t("h2",{attrs:{id:"观察者模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式"}},[n._v("#")]),n._v(" 观察者模式")]),n._v(" "),t("p",[n._v("观察者模式又叫发布-订阅模式。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象。")]),n._v(" "),t("p",[n._v("Subject(被观察对象)  addObserver, deleteObserver, Notify(dispatcher)"),t("br"),n._v("\nConcreteSubject(具体的被观察对象)"),t("br"),n._v("\nObserver(观察者)  handlerData"),t("br"),n._v("\nConcreteObserver(具体的观察者)")])])}),[],!1,null,null,null);a.default=r.exports}}]);