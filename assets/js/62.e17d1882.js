(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{448:function(a,t,n){"use strict";n.r(t);var l=n(46),e=Object(l.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h2",{attrs:{id:"c-c-应用场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#c-c-应用场景"}},[a._v("#")]),a._v(" C/C++应用场景")]),a._v(" "),n("ul",[n("li",[a._v("嵌入式系统（物联网）")]),a._v(" "),n("li",[a._v("网络游戏")]),a._v(" "),n("li",[a._v("防火墙、杀毒软件")]),a._v(" "),n("li",[a._v("人工智能")]),a._v(" "),n("li",[a._v("工业级应用")]),a._v(" "),n("li",[a._v("手机APP（高性能、高节能要求）")]),a._v(" "),n("li",[a._v("云计算")])]),a._v(" "),n("h2",{attrs:{id:"为什么要-lua-c-c"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么要-lua-c-c"}},[a._v("#")]),a._v(" 为什么要 Lua+C/C++")]),a._v(" "),n("ol",[n("li",[a._v("C++的缺点:编译慢，调试难，学习难度大")]),a._v(" "),n("li",[a._v("Lua优点:\n"),n("ul",[n("li",[a._v("最快的脚本语言")]),a._v(" "),n("li",[a._v("可以编译调试")]),a._v(" "),n("li",[a._v("与C/C++结合容易")]),a._v(" "),n("li",[a._v("Lua是对性能有要求的必备脚本")])])])]),a._v(" "),n("h2",{attrs:{id:"根据lua源代码生成"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#根据lua源代码生成"}},[a._v("#")]),a._v(" 根据lua源代码生成")]),a._v(" "),n("p",[a._v("动态库 预处理器")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("WIN32\n_DEBUG\nLUA53_EXPORTS\n_WINDOWS\n_USRDLL\n\n系统 _WINDOWS\n")])])]),n("p",[a._v("可执行程序")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("WIN32\n_DEBUG\n_CONSOLE\n\n系统 _CONSOLE\n")])])]),n("p",[a._v("创建DLL项目，选择Release模式。")]),a._v(" "),n("p",[a._v("将解压后的src文件夹下所有.h和.c文件（lua.c,luac.c和其他格式文件都不要）拖进项目，")]),a._v(" "),n("p",[a._v("预处理器定义（宏定义）加上LUA_BUILD_AS_DLL")]),a._v(" "),n("h2",{attrs:{id:"使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[a._v("#")]),a._v(" 使用")]),a._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('#pragma comment(lib, "lua.lib")  \nextern "C"  \n{  \n#include <lua.h>  \n#include <lualib.h>  \n#include <lauxlib.h>  \n};\n\nvoid TestLua();\n \nint main()\n{\n    TestLua();\n    return 0;\n}\n \nvoid TestLua()\n{\n    lua_State *L = luaL_newstate();\n    luaopen_base(L); //\n    luaopen_table(L); //\n    luaopen_package(L); //\n    luaopen_io(L); //\n    luaopen_string(L); //\n \n    luaL_openlibs(L); //打开以上所有的lib\n \n    string str; \n \n    while (true)\n    {\n        cout << "请输入Lua代码:" << endl;\n        getline(cin, str, \'\\n\');\n        if (luaL_loadstring(L, str.c_str())\n            || lua_pcall(L, 0, 0, 0) )\n        {\n            const char * error = lua_tostring(L, -1) ;\n            cout << string(error) << endl;\n        }\n    }\n \n    lua_close(L);\n}\n\n// 在C++中，每个嵌入的lua的生命周期与各自的lua_State对象一一对应。通过luaL_newstate()方法，我们便创建了一个lua解释器。随后的几个luaopen_*方法，都是获取相应lua库的使用权，最后通过luaL_openlibs打开所拥有使用权的lua标准库。\n// 通过luaL_loadstring，将所有代码读入lua，并且检查代码是否有语法错误。然后通过lua_pcall，运行代码，将所有的全局变量保存在L中。通过读取、运行这两步，我们就建立起一个自己的lua解释器了。\n// 将lua作为配置文件，从文件读取lua代码，流程与之前的示例一样，仅是将luaL_loadstring()换成luaL_loadfile()即可。\n\n\n')])])]),n("h2",{attrs:{id:"c与lua的交互机制"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#c与lua的交互机制"}},[a._v("#")]),a._v(" C与Lua的交互机制")]),a._v(" "),n("p",[a._v("正数索引和负数索引，从而使-1总是代表栈顶元素的索引，1总是代表栈底元素的索引")]),a._v(" "),n("p",[a._v("交互基本原理：")]),a._v(" "),n("p",[a._v("当C要调用Lua数据时，Lua把值压入栈中，C再从栈中取值；")]),a._v(" "),n("p",[a._v("当Lua调用C数据时，C要将数据压入栈中，让Lua从栈中取值。")]),a._v(" "),n("p",[a._v("交互值时大部分可以按上面的互相传输，但是交互函数稍微更复杂：")]),a._v(" "),n("p",[a._v("当C要调用Lua函数时，Lua先将Lua函数压入栈中，C再将数据（作为参数）继续压入栈中，")]),a._v(" "),n("p",[a._v("然后用API调用栈上的lua函数+参数，调用完后，Lua函数和参数都会出栈，而函数计算后的返还值会压入栈中。")]),a._v(" "),n("p",[a._v("当Lua要调用C函数时，需要通过API注册符合lua规范的C函数，来让Lua知道该C函数的定义。")]),a._v(" "),n("h2",{attrs:{id:"lua-api函数总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#lua-api函数总结"}},[a._v("#")]),a._v(" lua API函数总结")]),a._v(" "),n("h3",{attrs:{id:"将lua脚本里的变量压入栈中"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#将lua脚本里的变量压入栈中"}},[a._v("#")]),a._v(" 将Lua脚本里的变量压入栈中")]),a._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v('// 根据name获取某个全局变量，压入栈顶\nint lua_getglobal(lua_State *L, const char *name);\n\n// 根据name获取index索引的table元素里的某个变量，压入栈顶\nint lua_getfield(lua_State *L, int index, const char *name);\n// 以k所在栈中的索引(idx)作为参数，取得k对应的值并压入栈顶\nvoid lua_getfield(lua_State *L, int idx, const char *k)\n// lua_getfield必须为字符串键\n// lua_getglobal(L, "mytable") <== push mytable\n// lua_getfield(L, -1, "x")    <== push mytable["x"]，作用同下面两行调用\n// --lua_pushstring(L, "x")    <== push key "x"\n// --lua_gettable(L,-2)        <== pop key "x", push mytable["x"]\n\n// 将t[k]的值压入栈。t是栈中位于参数index所指向的位置，k为栈顶的值。此函数调用后，将会把栈顶的k的值出栈，将返回的结果放入栈顶。在lua中，这个调用将会触发metamethod的“index”事件。\n// idx指向表在栈中的位置，弹出栈顶的key取得表中的值并压入栈顶,此函数与lua_rawget的区别在于此函数会调用metatable的方法\nvoid lua_gettable(lua_State *L, int idx);\n// lua_gettable简单理解\n// lua_getglobal(L, "mytable") <== push mytable\n// lua_pushnumber(L, 1)        <== push key 1\n// lua_gettable(L, -2)         <== pop key 1, push mytable[1]\n')])])]),n("h3",{attrs:{id:"将c变量压入栈中"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#将c变量压入栈中"}},[a._v("#")]),a._v(" 将C变量压入栈中")]),a._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("//将数字压入栈顶\nvoid lua_pushnumber(lua_State *L,double number);\n//将字符串压入栈顶\nconst char *lua_pushstring(lua_State *L, const char *str);\n// lua_setglobal来用一个名字引用栈顶的值。\n")])])]),n("h3",{attrs:{id:"将栈中某个位置的元素提取成c变量"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#将栈中某个位置的元素提取成c变量"}},[a._v("#")]),a._v(" 将栈中某个位置的元素提取成C变量")]),a._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("//将index索引的元素以数字的形式提取\ndouble lua_tonumber(lua_State *L, int index);\n//将index索引的元素以字符串的形式提取，返还\nconst char* lua_tostring(lua_State *L, int index);\n")])])]),n("h3",{attrs:{id:"利用栈调用lua函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#利用栈调用lua函数"}},[a._v("#")]),a._v(" 利用栈调用lua函数")]),a._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("// 调用lua函数，arguNum是参数的个数，returnNum是返还值的个数，errorHandleIndex是函数调用错误时会另外调用的错误处理函数的索引（0视为无）\n// 调用前要求：依次压入 lua函数元素，第1个参数元素，第2个参数元素....\n// 调用后：调用的lua函数元素和所有参数元素 会在栈里被清理掉，并且若干个返还值元素将压入栈顶\n// lua_pcall()内部调用的是lua_call()\n// void lua_call(lua_State *L, int nargs, int nresults)\n// 首先，被调用的函数要被压入栈，该函数的参数要按照直接的顺序压入栈。第一个参数要第一个入栈，以此类推。最终你调用lua_call。nargs参数表示你压入栈中的参数个数。该函数及其所有的参数在被调用的时候都会从栈中弹出。函数的返回值将会在函数返回的时候压入栈中。返回值的个数用nresults这个参数来调整，除非传入的是LUA_MULTRET（注：即-1）。在这种情况下，函数的全部返回值都会入栈。lua会处理栈的空间，以使所有的返回值都有充足的栈空间。所有的返回值是以直接入栈的顺序压栈的（即第一返回值先入，依次类推），所以经过调用后，最后一个返回值在栈顶。\nint lua_pcall(lua_State *L, int arguNum, int returnNum, int errorHandleIndex);\n\n")])])]),n("h3",{attrs:{id:"以下函数用于判断栈内某处值的类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#以下函数用于判断栈内某处值的类型"}},[a._v("#")]),a._v(" 以下函数用于判断栈内某处值的类型")]),a._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("// 判断是，返回0\n// 栈idx处的值是否是实数\nint (lua_isnumber) (lua_State *L, int idx)\n// 栈idx处的值是否是字符串      \nint (lua_isstring) (lua_State *L, int idx)\n// 栈idx处的值是否是函数       \nint (lua_iscfunction) (lua_State *L, int idx)\n// 栈idx处的值是否是二进制数据\nint (lua_isuserdata) (lua_State *L, int idx)\n// 取得栈idx处的值的类型       \nint (lua_type) (lua_State *L, int idx)\n// 将类型转换成C字符串\nconst char *(lua_typename) (lua_State *L, int tp)\n// 栈内两个值是否相等，类型和值都需要相等才返回真       \nint (lua_equal) (lua_State *L, int idx1, int idx2)\n// 栈内两个对象是否相等，如果是对象时所指对象相同也算相等       \nint (lua_rawequal) (lua_State *L, int idx1, int idx2)\n// 栈内两个值的大小,idx1处的值是否小于idx2处的值     \nint (lua_lessthan) (lua_State *L, int idx1, int idx2)\n")])])]),n("h3",{attrs:{id:"以下函数往栈顶压入一个c值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#以下函数往栈顶压入一个c值"}},[a._v("#")]),a._v(" 以下函数往栈顶压入一个C值")]),a._v(" "),n("div",{staticClass:"language-c++ extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("// 往栈顶压入一个NIL值\nvoid (lua_pushnil) (lua_State *L)\n// 往栈顶压入一个实数        \nvoid (lua_pushnumber) (lua_State *L, lua_Number n)\n// 往栈顶压入一个整数        \nvoid (lua_pushinteger) (lua_State *L, lua_Integer n)\n// 往栈顶压入一个二进制串        \nvoid (lua_pushlstring) (lua_State *L, const char *s, size_t l)\n// 往栈顶压入一个字符串        \nvoid (lua_pushstring) (lua_State *L, const char *s)\n// 往栈顶压入一个格式化串，不过argp是变参        \nconst char *(lua_pushvfstring) (lua_State *L, const char *fmt, va_list argp)\n// 往栈顶压入一个格式化串        \nconst char *(lua_pushfstring) (lua_State *L, const char *fmt, ...)\n// 压入一个函数        \nvoid (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n)\n// 往栈顶压入一个bool类型        \nvoid (lua_pushboolean) (lua_State *L, int b)\n// 往栈顶压入一个数组，数组的内存块指向p        \nvoid (lua_pushlightuserdata) (lua_State *L, void *p)\n// 将一个C函数入栈。这个函数接受一个C函数指针，将其压入作为一个Lua的function类型值压入栈，当这个值被调用时，Lua将调用该值对应的C函数。所有注册在Lua中的C函数必须遵守一个正确的协议来接受参数和返回返回值（查看lua_CFunction）。\nvoid lua_pushcfuntion(lua_State *L, luaCFunction f)\n// 为了正确的与Lua交互，必须遵守如下协议，该协议定义了参数和返回值的传递方式：一个C函数从Lua的栈中以直接（左边的参数先入栈）顺序来接收参数。因此，当该函数的调用开始时，lua_gettop(L) 得到用来调用该函数的参数个数（注：lua_gettop的作用是得到栈的栈顶元素的索引，即栈的长度）。第一个参数（如果有的话）的值索引为1，最后一个参数的值索引为lua_gettop(L)。为了将返回值返回给Lua，C函数将所有的返回值以直接的顺序（第一个返回值先入栈，以此类推）全部压入栈中，然后将返回值的个数作为值返回（注：此处的返回是return之意，不是传递到Lua中）。所有栈中其他的在返回值个数之下的索引对应的值会被Lua忽略掉，被Lua调用的C函数能传递多个值返回给Lua。\n")])])])])}),[],!1,null,null,null);t.default=e.exports}}]);