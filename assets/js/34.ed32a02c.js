(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{475:function(t,a,r){"use strict";r.r(a);var n=r(46),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"_1-友元"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-友元"}},[t._v("#")]),t._v(" 1 友元")]),t._v(" "),r("h3",{attrs:{id:"_1-1-友元函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-友元函数"}},[t._v("#")]),t._v(" 1.1 友元函数")]),t._v(" "),r("p",[t._v("友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数,它不属于任何类,但需要在类的定义中加以声明,声明时只需在友元的名称前加上关键字friend，格式为：friend 类型 函数名(形式参数);\t 一个函数可以是多个类的友元函数,只需要在各个类中分别声明。")]),t._v(" "),r("div",{staticClass:"language-c++ extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("//友元函数的目的就是为了访问类的私有数据成员\n//全局函数作友元函数\nfriend double Distance(Point &a, Point &b);\t\n//类的成员函数作友元函数\nfriend double ManagerPoint::Distance(Point &a, Point &b);\t\n")])])]),r("h3",{attrs:{id:"_1-2-友元类"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-友元类"}},[t._v("#")]),t._v(" 1.2 友元类")]),t._v(" "),r("p",[t._v("友元类的所有成员函数都是另一个类的友元函数,都可以访问另一个类中的隐藏信息(包括私有成员和保护成员)。 当希望一个类可以存取另一个类的私有成员时,可以将该类声明为另一类的友元类。"),r("br"),t._v("\n定义友元类的语句格式如下:"),r("br"),t._v("\nfriend class 类名;\t"),r("br"),t._v("\n其中:friend和class是关键字,类名必须是程序中的⼀个已定义过的类。")]),t._v(" "),r("div",{staticClass:"language-bash extra-class"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[t._v("例如,以下语句说明类B是类A的友元类:\t\nclass A\t\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\t\n\tpublic:\t\n\t\tfriend class B"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\t\n\t\t"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v(".\t\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n经过以上说明后,类B的所有成员函数都是类A的友元函数,能存取类A的私有成员和保护成员。\n")])])]),r("h3",{attrs:{id:"_1-3-注意事项"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-注意事项"}},[t._v("#")]),t._v(" 1.3 注意事项")]),t._v(" "),r("ol",[r("li",[t._v("因为友元不是授权类的成员,所以它不受其所在类的声明区域public private和protected的影响。通常我们选择把所有友元声明组织在一起并放在类头之后。")]),t._v(" "),r("li",[t._v("友元关系不能被继承。")]),t._v(" "),r("li",[t._v("友元关系是单向的,不具有交换性。若类B是类A的友元,类A不一定是类B的友元,要看在类中是否有相应的声明。")]),t._v(" "),r("li",[t._v("友元关系不具有传递性。若类B是类A的友元,类C是B的友元,类C不一定是类A的友元,同样要看类中是否有相应的声明。")])]),t._v(" "),r("h2",{attrs:{id:"_2-运算符重载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-运算符重载"}},[t._v("#")]),t._v(" 2 运算符重载")]),t._v(" "),r("p",[t._v("运算符重载的本质是函数重载。")]),t._v(" "),r("h3",{attrs:{id:"_2-1-重载规则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-重载规则"}},[t._v("#")]),t._v(" 2.1 重载规则")]),t._v(" "),r("p",[t._v("可被重载的运算符：new, new[], delete, delete[], +, -, "),r("em",[t._v(", /, %, ^, &, |, ~, !, =, ..., ,, ->")]),t._v(", ->, (), []\n不能重载的运算符：.; ::; .*; ?: ;"),r("br"),t._v("\n重载方式: 友元重载和成员重载")]),t._v(" "),r("h3",{attrs:{id:"_2-2-单目操作符重载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-单目操作符重载"}},[t._v("#")]),t._v(" 2.2 单目操作符重载")]),t._v(" "),r("p",[t._v("重点区分前置操作还是后置操作")]),t._v(" "),r("div",{staticClass:"language-c++ extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("// 前++\nfriend Complex& operator++(Complex& c);\t\nComplex& operator++(Complex& c)\t\t\n{\t\n\tc._x++;\t\n\tc._y++;\t\t\n\treturn c;\t\t\t\n}\t\n// 后++\nfriend const Complex operator++(Complex &c,int);\nconst Complex operator++(Complex &c,int)\n{\t\n\tComplex\tt(c._x,c._y);\n\tc._x++;\n  \tc._y++;\n\treturn t;\n}\n// 也可以用下面的方式定义\nconst Complex operator++(int)\n{\n\tComplex\tt = *this;\t\n\t_x++;\n\t_y++;\n\treturn t;\n}\n")])])]),r("h3",{attrs:{id:"_2-3-输入输出运算符重载-只能通过友元函数重载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-输入输出运算符重载-只能通过友元函数重载"}},[t._v("#")]),t._v(" 2.3 输入输出运算符重载（只能通过友元函数重载）")]),t._v(" "),r("p",[t._v("需要通过友元来实现,避免修改c++的标准库。")]),t._v(" "),r("div",{staticClass:"language-c++ extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('friend ostream& operator<<(ostream &os,\tconst Complex& c);\t\nfriend istream& operator>>(istream &is,\tComplex& c);\t\n\nostream& operator<<(ostream\t&os, const Complex& c)\t\t\n{\t\n\tos<<"("<<c._x<<","<<c._y<<")";\t\n\treturn\tos;\t\t\n}\t\nistream& operator>>(istream&is, Complex& c)\t\t\n{\t\n\tis>>c._x>>c._y;\t\n\treturn\tis;\t\t\t\t\t\t\n}\n')])])]),r("h3",{attrs:{id:"_2-4-只能通过成员函数重载的运算符"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-只能通过成员函数重载的运算符"}},[t._v("#")]),t._v(" 2.4 只能通过成员函数重载的运算符")]),t._v(" "),r("h4",{attrs:{id:"_2-4-1-赋值运算符重载-operator"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-1-赋值运算符重载-operator"}},[t._v("#")]),t._v(" 2.4.1 赋值运算符重载 (operator=)")]),t._v(" "),r("p",[t._v("用一个己有对象,给另外一个己有对象赋值。两个对象均己创建结束后,发\n生的赋值行为。")]),t._v(" "),r("div",{staticClass:"language-c++ extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("String& String::operator=(const String& str)\n{\n\t//1.首先判断是否赋值给自己\n   \tif (this == &str)\n     \treturn *this;\n\t//2.删除指针之前分配的内存\n    delete[] m_data;\n\t//3.拷贝，需要分配内存，最好通过new进行分配\n    m_data = new char[strlen(str.m_data) + 1 ];\n    strcpy(m_data, str.m_data);\n    return *this;\n}\n")])])]),r("h4",{attrs:{id:"_2-4-2-数组下标运算符-operator"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-2-数组下标运算符-operator"}},[t._v("#")]),t._v(" 2.4.2 数组下标运算符 (operator[])")]),t._v(" "),r("p",[t._v("设 x 是类 X 的一个对象，则表达式 x[y] 可被解释为 x.operator[](y)")]),t._v(" "),r("div",{staticClass:"language-c++ extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("int& operator[](int index) \n{\n\treturn v[i];\n}\n")])])]),r("h4",{attrs:{id:"_2-4-3-函数调用符号-operator"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-3-函数调用符号-operator"}},[t._v("#")]),t._v(" 2.4.3 函数调用符号 (operator())")]),t._v(" "),r("p",[t._v("把类对象像函数名一样使用。"),r("br"),t._v("\n仿函数(functor),就是使一个类的使用看上去象一个函数。其实现就是类中实现一个operator(),这个类就有了类似函数的行为,就是一个仿函数类了。")]),t._v(" "),r("div",{staticClass:"language-c++ extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("#include <iostream>\nusing namespace\tstd;\t\nclass Sqr\t\n{\t\npublic:\t\n\tint operator()(int\ti)\t\n\t{\t\n\t\treturn i*i;\t\n\t}\t\n\tdouble operator()(double\td)\t\n\t{\t\n\t\treturn d*d;\t\n\t}\n};\t\nint\tmain()\t\n{\t\n\tSqr\tsqr;\t\n\tint\ti = sqr(4);\t\n\tdouble d =\tsqr(5.5);\t\n\tcout<<i<<endl;\t\n\tcout<<d<<endl;\t\n\treturn 0;\t\t\n}\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);