(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{406:function(e,t,s){"use strict";s.r(t);var r=s(46),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"libcurl库使用方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#libcurl库使用方法"}},[e._v("#")]),e._v(" libcurl库使用方法")]),e._v(" "),s("h2",{attrs:{id:"一、-概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、-概念"}},[e._v("#")]),e._v(" 一、 概念")]),e._v(" "),s("p",[e._v("libcurl作为是一个多协议的便于客户端使用的URL传输库，基于C语言，提供C语言的API接口，支持DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMTP, SMTPS, Telnet and TFTP这些协议，同时支持使用SSL证书的安全文件传输：HTTP POST, HTTP PUT, FTP 上传, 基于HTTP形式的上传、代理、Cookies、用户加密码的认证等多种应用场景。另外，libcurl是一个高移植性的库，能在绝大多数系统上运行，包括Solaris, NetBSD, FreeBSD, OpenBSD, Darwin, HPUX, IRIX, AIX, Tru64, Linux, UnixWare, HURD, Windows, Amiga, OS/2, BeOs, Mac OS X, Ultrix, QNX, OpenVMS, RISC OS, Novell NetWare, DOS等。")]),e._v(" "),s("h2",{attrs:{id:"二、使用步骤"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、使用步骤"}},[e._v("#")]),e._v(" 二、使用步骤")]),e._v(" "),s("ol",[s("li",[e._v("调用curl_global_init()初始化libcurl")]),e._v(" "),s("li",[e._v("调用curl_easy_init()函数得到 easy interface型指针")]),e._v(" "),s("li",[e._v("调用curl_easy_setopt()设置传输选项")]),e._v(" "),s("li",[e._v("根据curl_easy_setopt()设置的传输选项，实现回调函数以完成用户特定任务")]),e._v(" "),s("li",[e._v("调用curl_easy_perform()函数完成传输任务")]),e._v(" "),s("li",[e._v("调用curl_easy_cleanup()释放内存")]),e._v(" "),s("li",[e._v("调用curl_global_cleanup()析构libcurl\n在整过过程中设置curl_easy_setopt()参数是最关键的，几乎所有的libcurl程序都要使用它。")])]),e._v(" "),s("p",[e._v("在基于Libcurl的程序里，主要采用callback function （回调函数）的形式完成传输任务，用户在启动传输前设置好各类参数和回调函数，当满足条件时libcurl将调用用户的回调函数实现特定功能。")]),e._v(" "),s("h2",{attrs:{id:"三、函数说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、函数说明"}},[e._v("#")]),e._v(" 三、函数说明")]),e._v(" "),s("h3",{attrs:{id:"_1-curlcode-curl-global-init-long-flags"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-curlcode-curl-global-init-long-flags"}},[e._v("#")]),e._v(" 1 CURLcode curl_global_init(long flags);")]),e._v(" "),s("p",[e._v("描述：\n这个函数只能用一次。(其实在调用curl_global_cleanup 函数后仍然可再用)\n如果这个函数在curl_easy_init函数调用时还没调用，它讲由libcurl库自动调用，所以多线程下最好主动调用该函数以防止在线程中curl_easy_init时多次调用。")]),e._v(" "),s("p",[e._v("注意：虽然libcurl是线程安全的，但curl_global_init是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。"),s("strong",[e._v("将其放在构造函数中较为合适")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("参数：flags\nCURL_GLOBAL_ALL          //初始化所有的可能的调用。\nCURL_GLOBAL_SSL          //初始化支持 安全套接字层。\nCURL_GLOBAL_WIN32        //初始化win32套接字库。\nCURL_GLOBAL_NOTHING      //没有额外的初始化。\n")])])]),s("h3",{attrs:{id:"_2-void-curl-global-cleanup-void"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-void-curl-global-cleanup-void"}},[e._v("#")]),e._v(" 2 void curl_global_cleanup(void);")]),e._v(" "),s("p",[e._v("描述：在结束libcurl使用的时候，用来对curl_global_init做的工作清理。类似于close的函数。")]),e._v(" "),s("p",[e._v("注意：虽然libcurl是线程安全的，但curl_global_cleanup是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init，应该将该函数的调用放在主线程中。")]),e._v(" "),s("h3",{attrs:{id:"_3-char-curl-version"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-char-curl-version"}},[e._v("#")]),e._v(" 3 char *curl_version( );")]),e._v(" "),s("p",[e._v("描述: 打印当前libcurl库的版本。")]),e._v(" "),s("h3",{attrs:{id:"_4-curl-curl-easy-init"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-curl-curl-easy-init"}},[e._v("#")]),e._v(" 4 CURL *curl_easy_init( );")]),e._v(" "),s("p",[e._v("描述:\ncurl_easy_init用来初始化一个CURL的指针(有些像返回FILE类型的指针一样). 相应的在调用结束时要用curl_easy_cleanup函数清理.\n一般curl_easy_init意味着一个会话的开始. 它会返回一个easy_handle(CURL*对象), 一般都用在easy系列的函数中.")]),e._v(" "),s("h3",{attrs:{id:"_5-void-curl-easy-cleanup-curl-handle"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-void-curl-easy-cleanup-curl-handle"}},[e._v("#")]),e._v(" 5 void curl_easy_cleanup(CURL *handle);")]),e._v(" "),s("p",[e._v("描述:\n这个调用用来结束一个会话.与curl_easy_init配合着用.\n参数:\nCURL类型的指针.")]),e._v(" "),s("h3",{attrs:{id:"_6-curlcode-curl-easy-setopt-curl-handle-curloption-option-parameter"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-curlcode-curl-easy-setopt-curl-handle-curloption-option-parameter"}},[e._v("#")]),e._v(" 6 CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);")]),e._v(" "),s("p",[e._v("描述: 这个函数最重要了，几乎所有的curl 程序都要频繁的使用它.它告诉curl库.程序将有如何的行为. 比如要查看一个网页的html代码等.(这个函数有些像ioctl函数)参数:")]),e._v(" "),s("ol",[s("li",[e._v("CURL类型的指针")]),e._v(" "),s("li",[e._v("各种CURLoption类型的选项.(都在curl.h库里有定义,man 也可以查看到)")]),e._v(" "),s("li",[e._v("parameter 这个参数 既可以是个函数的指针,也可以是某个对象的指针,也可以是个long型的变量.它用什么这取决于第二个参数.\nCURLoption 这个参数的取值很多.具体的可以查看man手册.")])]),e._v(" "),s("h3",{attrs:{id:"_7-curlcode-curl-easy-perform-curl-handle"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-curlcode-curl-easy-perform-curl-handle"}},[e._v("#")]),e._v(" 7 CURLcode curl_easy_perform(CURL *handle);")]),e._v(" "),s("p",[e._v("描述:这个函数在初始化CURL类型的指针 以及curl_easy_setopt完成后调用. 就像字面的意思所说perform就像是个舞台.让我们设置的\noption 运作起来.参数:\nCURL类型的指针.")]),e._v(" "),s("h3",{attrs:{id:"_8-void-curl-global-cleanup-void"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-void-curl-global-cleanup-void"}},[e._v("#")]),e._v(" 8 void curl_global_cleanup(void);")]),e._v(" "),s("p",[e._v("释放libcurl")]),e._v(" "),s("h2",{attrs:{id:"四、curl-easy-setopt函数部分选项介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、curl-easy-setopt函数部分选项介绍"}},[e._v("#")]),e._v(" 四、curl_easy_setopt函数部分选项介绍")]),e._v(" "),s("p",[e._v("本节主要介绍curl_easy_setopt中跟http相关的参数。该函数是curl中非常重要的函数，curl所有设置都是在该函数中完成的，该函数的设置选项众多，注意本节的阐述的只是部分常见选项。")]),e._v(" "),s("ol",[s("li",[e._v("CURLOPT_URL —— 设置访问URL")]),e._v(" "),s("li",[e._v("CURLOPT_WRITEFUNCTION，CURLOPT_WRITEDATA\n回调函数原型为：")])]),e._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('size_t function( void *ptr, size_t size, size_t nmemb, void *stream); \ncurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, req_reply);\ncurl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&response);\n\n// reply of the requery  \n// 将返回的内容写入到stream中\nsize_t req_reply(void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    if (stream == NULL || ptr == NULL || size == 0)\n        return 0;\n \n    size_t realsize = size * nmemb;\n    std::string *buffer = (std::string*)stream;\n    if (buffer != NULL)\n    {\n        buffer->append((const char *)ptr, realsize);\n    }\n    return realsize;\n}\n\nCURLcode curl_get_req(const std::string &url, std::string &response, std::list<std::string> listRequestHeader, bool bResponseIsWithHeaderData = false, int nConnectTimeout = 10, int nTimeout = 10)\n{\n    // init curl  \n    CURL *curl = curl_easy_init();\n    // res code  \n    CURLcode res;\n    if (curl)\n    {\n        // set params  \n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); // url  \n        //curl_easy_setopt(m_curl, CURLOPT_PORT, 8089);    //port\n        curl_easy_setopt(curl, CURLOPT_POST, 0); // get reqest \n        //构建HTTP报文头\n        struct curl_slist* headers = NULL;\n        if (listRequestHeader.size() > 0)\n        {\n            std::list<std::string>::iterator iter, iterEnd;\n            iter = listRequestHeader.begin();\n            iterEnd = listRequestHeader.end();\n            for (iter; iter != iterEnd; iter++)\n            {\n                headers = curl_slist_append(headers, iter->c_str());\n            }\n            //headers = curl_slist_append(headers, "Content-Type:application/json;charset=UTF-8");\n            //headers = curl_slist_append(headers, "Content-Type:application/x-www-form-urlencoded");\n            if (headers != NULL)\n            {\n                curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);//设置http请求头信息\n            }\n        }\n        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false); // if want to use https  \n        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, false); // set peer and host verify false  \n        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);\n        curl_easy_setopt(curl, CURLOPT_READFUNCTION, NULL);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, req_reply);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&response);\n        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n        if (bResponseIsWithHeaderData)\n        {\n            curl_easy_setopt(curl, CURLOPT_HEADER, 1);//响应体中是否包含了头信息，比如Content-Type:application/json;charset=UTF-8\n        }\n        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, nConnectTimeout); // set transport and time out time  \n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, nTimeout);\n        // start request  \n        res = curl_easy_perform(curl);\n        if (headers != NULL)\n        {\n            curl_slist_free_all(headers); //free the list again\n        }\n    }\n    // release curl  \n    curl_easy_cleanup(curl);\n    return res;\n}\n')])])]),s("ul",[s("li",[e._v("函数将在libcurl接收到数据后被调用，因此函数多做数据保存的功能，如处理下载文件。")]),e._v(" "),s("li",[e._v("CURLOPT_WRITEDATA 用于表明CURLOPT_WRITEFUNCTION函数中的stream指针的来源。通过 CURLOPT_WRITEDATA属性给默认回调函数传递一个已经打开的文件指针，用于将数据输出到文件里。")]),e._v(" "),s("li",[e._v("如果你没有通过CURLOPT_WRITEFUNCTION属性给easy handle设置回调函数，libcurl会提供一个默认的回调函数，它只是简单的将接收到的数据打印到标准输出。")])]),e._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[e._v("CURLOPT_HEADERFUNCTION，CURLOPT_HEADERDATA\n回调函数原型为")])]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("size_t function( void *ptr, size_t size,size_t nmemb, void *stream);\n")])])]),s("p",[e._v("libcurl一旦接收到http 头部数据后将调用该函数。CURLOPT_WRITEDATA 传递指针给libcurl，该指针表明CURLOPT_HEADERFUNCTION 函数的stream指针的来源。")]),e._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[s("p",[e._v("CURLOPT_READFUNCTION, CURLOPT_READDATA\nlibCurl需要读取数据传递给远程主机时将调用CURLOPT_READFUNCTION指定的函数，函数原型是：size_t function(void *ptr, size_t size, size_t nmemb,void *stream). CURLOPT_READDATA 表明CURLOPT_READFUNCTION函数原型中的stream指针来源.")])]),e._v(" "),s("li",[s("p",[e._v("CURLOPT_NOPROGRESS，CURLOPT_PROGRESSFUNCTION，CURLOPT_PROGRESSDATA\n跟数据传输进度相关的参数。CURLOPT_PROGRESSFUNCTION 指定的函数正常情况下每秒被libcurl调用一次，为了使CURLOPT_PROGRESSFUNCTION被调用，CURLOPT_NOPROGRESS必须被设置为false，CURLOPT_PROGRESSDATA指定的参数将作为CURLOPT_PROGRESSFUNCTION指定函数的第一个参数")])]),e._v(" "),s("li",[s("p",[e._v("CURLOPT_TIMEOUT，CURLOPT_CONNECTIONTIMEOUT:\nCURLOPT_TIMEOUT 由于设置传输时间，CURLOPT_CONNECTIONTIMEOUT 设置连接等待时间")])]),e._v(" "),s("li",[s("p",[e._v("CURLOPT_FOLLOWLOCATION\n设置重定位URL")])])]),e._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1); //返回的头部中有Location(一般直接请求的url没找到)，则继续请求Location对应的数据\n")])])]),s("ol",{attrs:{start:"8"}},[s("li",[e._v("CURLOPT_RANGE: CURLOPT_RESUME_FROM:\n断点续传相关设置。CURLOPT_RANGE 指定char *参数传递给libcurl，用于指明http域的RANGE头域，例如：\n表示头500个字节：bytes=0-499\n表示第二个500字节：bytes=500-999\n表示最后500个字节：bytes=-500\n表示500字节以后的范围：bytes=500-\n第一个和最后一个字节：bytes=0-0,-1\n同时指定几个范围：bytes=500-600,601-999\nCURLOPT_RESUME_FROM 传递一个long参数给libcurl，指定你希望开始传递的偏移量。")])]),e._v(" "),s("h2",{attrs:{id:"五、libcurl使用的http消息头"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、libcurl使用的http消息头"}},[e._v("#")]),e._v(" 五、libcurl使用的HTTP消息头")]),e._v(" "),s("p",[e._v('当使用libcurl发送http请求时，它会自动添加一些http头。我们可以通过CURLOPT_HTTPHEADER属性手动替换、添加或删除相应 的HTTP消息头。\nHost\nhttp1.1（大部分http1.0)版本都要求客户端请求提供这个信息头。\nPragma\n"no-cache"。表示不要缓冲数据。\nAccept\n"'),s("em",[e._v("/")]),e._v('"。表示允许接收任何类型的数据。\nExpect\n以POST的方式向HTTP服务器提交请求时，libcurl会设置该消息头为"100-continue"，它要求服务器在正式处理该请求之前，返回一 个"OK"消息。如果POST的数据很小，libcurl可能不会设置该消息头。\n自定义选项\n当前越来越多的协议都构建在HTTP协议之上（如：soap），这主要归功于HTTP的可靠性，以及被广泛使用的代理支持（可以穿透大部分防火墙）。 这些协议的使用方式与传统HTTP可能有很大的不同。对此，libcurl作了很好的支持。\n自定义请求方式(CustomRequest)\nHTTP支持GET, HEAD或者POST提交请求。可以设置CURLOPT_CUSTOMREQUEST来设置自定义的请求方式，libcurl默认以GET方式提交请求：\ncurl_easy_setopt(easy_handle, CURLOPT_CUSTOMREQUEST, "MYOWNREQUEST");')]),e._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('struct curl_slist *headers=NULL; /* init to NULL is important */ \nheaders = curl_slist_append(headers, "Hey-server-hey: how are you?"); \nheaders = curl_slist_append(headers, "X-silly-content: yes"); /* pass our list of custom made headers */ \n//post请求头的json数据格式\n//Content-Type:application/json;charset=UTF-8\ncurl_easy_setopt(easyhandle, CURLOPT_HTTPHEADER, headers); \ncurl_easy_perform(easyhandle); /* transfer http */ \ncurl_slist_free_all(headers); /* free the header list */\n')])])]),s("h2",{attrs:{id:"六、获取http应答头信息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#六、获取http应答头信息"}},[e._v("#")]),e._v(" 六、获取http应答头信息")]),e._v(" "),s("p",[e._v("发出http请求后，服务器会返回应答头信息和应答数据，如果仅仅是打印应答头的所有内容，则直接可以通过curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, 打印函数)的方式来完成，这里需要获取的是应答头中特定的信息，比如应答码、cookies列表等，则需要通过下面这个函数：\nCURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ... );\ninfo参数就是我们需要获取的内容，下面是一些参数值:")]),e._v(" "),s("ol",[s("li",[e._v("CURLINFO_RESPONSE_CODE"),s("br"),e._v("\n获取应答码")]),e._v(" "),s("li",[e._v("CURLINFO_HEADER_SIZE\n头大小")]),e._v(" "),s("li",[e._v("CURLINFO_COOKIELIST\ncookies列表")])]),e._v(" "),s("p",[e._v("除了获取应答信息外，这个函数还能获取curl的一些内部信息，如请求时间、连接时间等等。")]),e._v(" "),s("h2",{attrs:{id:"七、多线程问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#七、多线程问题"}},[e._v("#")]),e._v(" 七、多线程问题")]),e._v(" "),s("p",[e._v("首先一个基本原则就是：绝对不应该在线程之间共享同一个libcurl handle(CURL *对象)，不管是easy handle还是multi handle（本文只介绍easy_handle）。一个线程每次只能使用一个handle。\nlibcurl是线程安全的，但有两点例外：信号(signals)和SSL/TLS handler。 信号用于超时失效名字解析(timing out name resolves)。libcurl依赖其他的库来支持SSL/STL，所以用多线程的方式访问HTTPS或FTPS的URL时，应该满足这些库对多线程 操作的一些要求。详细可以参考：\nOpenSSL: http://www.openssl.org/docs/crypto/threads.html#DESCRIPTION")]),e._v(" "),s("p",[e._v("GnuTLS: http://www.gnu.org/software/gnutls/manual/html_node/Multi_002dthreaded-applications.html")]),e._v(" "),s("h2",{attrs:{id:"八、http验证"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#八、http验证"}},[e._v("#")]),e._v(" 八、HTTP验证")]),e._v(" "),s("p",[e._v('在使用HTTP协议时，客户端有很多种方式向服务器提供验证信息。默认的 HTTP验证方法是"Basic”，它将用户名与密码以明文的方式、经Base64编码后保存在HTTP请求头中，发往服务器。当然这不太安全。\n当前版本的libcurl支持的验证方法有：basic, Digest, NTLM, Negotiate, GSS-Negotiate and SPNEGO。可以通过CURLOPT_HTTPAUTH属性来设置具体 的验证方式：')]),e._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH, CURLAUTH_DIGEST);\n//向代理服务器发送验证信息时，可以通过CURLOPT_PROXYAUTH设置验证方式：\ncurl_easy_setopt(easy_handle, CURLOPT_PROXYAUTH, CURLAUTH_NTLM);\n//也可以同时设置多种验证方式（通过按位与）， 使用‘CURLAUTH_ANY‘将允许libcurl可以选择任何它所支持的验证方式。通过CURLOPT_HTTPAUTH或 CURLOPT_PROXYAUTH属性设置的多种验证方式，libcurl会在运行时选择一种它认为是最好的方式与服务器通信：\ncurl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH, CURLAUTH_DIGEST|CURLAUTH_BASIC); \n// curl_easy_setopt(easy_handle, CURLOPT_HTTPAUTH, CURLAUTH_ANY);\n")])])]),s("h2",{attrs:{id:"九、编译libcurl库"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#九、编译libcurl库"}},[e._v("#")]),e._v(" 九、编译libcurl库")]),e._v(" "),s("p",[e._v("从网站https://curl.haxx.se/download找到源码包，官网最新版为7.56.0，但是这个压缩包的curl-7.56.0\\projects\\Windows路径下VC6-VC14各个版本的VS解决方案。")]),e._v(" "),s("h3",{attrs:{id:"_9-1-如果需要libcur支持https-需要openssl库支持。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-1-如果需要libcur支持https-需要openssl库支持。"}},[e._v("#")]),e._v(" 9.1 如果需要libcur支持https，需要openssl库支持。")]),e._v(" "),s("p",[e._v("libcurl主要功能就是用不同的协议连接和沟通不同的服务器，如果使用HTTPS，需要OpenSSL")]),e._v(" "),s("p",[e._v("libcurl https://curl.haxx.se/download.html 下载Source Archives即可")]),e._v(" "),s("p",[e._v("ActiveState https://www.activestate.com/activeperl/downloads 下载perl解析器，编译openssl需要用到。")]),e._v(" "),s("p",[e._v("openssl https://www.openssl.org/source/ 下载openssl-1.0.2k，1.1.0以后的文件和安装方法都换了。")]),e._v(" "),s("p",[e._v("zlib http://zlib.net/ 下载1.2.7以外的版本，比如1.2.11。")]),e._v(" "),s("p",[e._v("支持https的libcurl库编译方法：")]),e._v(" "),s("ol",[s("li",[e._v("解压")])]),e._v(" "),s("p",[e._v("为了方便安装，在D盘根目录下新建一个名为libcurl-ssl的文件夹，将下载的三个压缩包解压到该文件夹。\n在 curl-7.54.0 -> lib 下新建文件夹openssl用来存放openssl的头文件。")]),e._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[e._v("zlib编译：")])]),e._v(" "),s("p",[e._v("zlib-1.2.11\\contrib\\vstudio\\vc14\\zlibvc.sln，编译release版本。")]),e._v(" "),s("p",[e._v("在生成的x86\\ZlibDllRelease文件夹中有zlibwapi.dll和zlibwapi.lib文件")]),e._v(" "),s("ol",{attrs:{start:"3"}},[s("li",[e._v("ActiveState安装：")])]),e._v(" "),s("p",[e._v("打开安装包，选择Modify默认安装或Repair修改安装路径都可以")]),e._v(" "),s("ol",{attrs:{start:"4"}},[s("li",[e._v("openssl编译：")])]),e._v(" "),s("p",[e._v("这是最麻烦、最容易出错的一环了，因为他没有项目文件，只能通过命令行来编译。")]),e._v(" "),s("p",[e._v("在开始菜单中找到vs自带的 VS2015 x86 本机工具命令提示符")]),e._v(" "),s("p",[e._v("使用cd命令进入到openssl-1.0.2k文件夹中")]),e._v(" "),s("p",[e._v("命令行键入 perl Configure VC-WIN32 no-asm")]),e._v(" "),s("p",[e._v("命令行键入 ms\\do_ms.bat")]),e._v(" "),s("p",[e._v("命令行键入 nmake -f ms/ntdll.mak")]),e._v(" "),s("p",[e._v("等待差不多五分钟，只要不出现“stop”，安全地执行到结束，就算成功。\n一旦中间出了差错，最好是把文件夹也删了，重新解压、配置编译，如果你留有编译失败的半成品，它可能会告诉你“无法解析XXX”。")]),e._v(" "),s("ol",{attrs:{start:"5"}},[s("li",[e._v("将 openssl-1.0.2k -> inc32 -> openssl 所有的.h 和 openssl-1.0.2k -> out32dll 的 libeay32.lib、libeay32.dll、ssleay32.lib、ssleay32.dll 一起复制到 curl-7.54.0 -> lib -> openssl 中")])]),e._v(" "),s("p",[e._v("libcurl编译：")]),e._v(" "),s("p",[e._v("编译平台选择 DLL Debug - DLL OpenSSL")]),e._v(" "),s("p",[e._v("curl-7.54.0 ->projects -> Windows -> VC14 -> curl-all.sln，可能会提示升级工程，确定即可。")]),e._v(" "),s("p",[e._v("将 libcurl 设为启动项目，选择 libcurl -> Resource Files -> libcurl.rc，右键“移出”，它记录着版本信息，只会增大文件，可以移出掉。")]),e._v(" "),s("p",[e._v('选择 属性 -> C/C++ -> 预处理器 -> 预处理器定义，将"BUILDING_LIBCURL"改成"CURL_STATICLIB"。这样那些接口函数就不会被声明为导出函数了。')]),e._v(" "),s("p",[e._v("选择 属性 -> 链接器 -> 常规 -> 附加库目录 添加 ........\\lib\\openssl，指向curl-7.54.0 -> lib -> openssl")]),e._v(" "),s("p",[e._v("选择 属性 -> 链接器 -> 输入 -> 附加依赖项 添加 libeay32.lib;ssleay32.lib;ws2_32.lib;wldap32.lib; 前两个是为了OpenSSL，后两个是CURL必须依赖的。")]),e._v(" "),s("p",[e._v("在编译成功后 curl-7.54.0 -> build -> Win32 -> VC14 -> DLL Debug - DLL OpenSSL 文件夹中会生成有 libcurld.dll 和 libcurld.lib（注意名字不是libcurl）。")]),e._v(" "),s("h3",{attrs:{id:"_9-2不支持https的libcurl库编译方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-2不支持https的libcurl库编译方法"}},[e._v("#")]),e._v(" 9.2不支持https的libcurl库编译方法：")]),e._v(" "),s("p",[e._v("使用curl-7.32.0版本中vs工程，vc自动编译。从网站https://curl.haxx.se/download 中下载curl-7.32.0版本。解压curl-7.32.0，找到vs工程目录，比如：curl-7.32.0\\vs\\vc8\\lib\\vc8libcurl.vcproj")]),e._v(" "),s("ol",[s("li",[s("p",[e._v("打开curl-7.32.0\\vs\\vc8\\lib\\vc8libcurl.vcproj文件，VS2010会提示升级工程，下一步即可。\nVC工程里有些设置问题导致不能直接编译，需要稍作修改")])]),e._v(" "),s("li",[s("p",[e._v('打开工程属性 > C\\C++ > 常规 > 附加包含目录。这里的包含目录是"..\\include"，而这个目录根本就不存在，它应该指向"curl-7.32.0\\include"才对，所以把这里改成"......\\include"。(或者直接完整路径也可以）')])]),e._v(" "),s("li",[s("p",[e._v('打开工程属性 > C\\C++ > 预处理器 > 预处理器定义。这里有个默认宏"BUILDING_LIBCURL"，如果要编译生成静态库，则要把它改成"CURL_STATICLIB"。这样，那些接口函数就不会被声明为导出函数了。')])]),e._v(" "),s("li",[s("p",[e._v("打开工程属性 > C\\C++ > 库管理器 > 常规 > 附加依赖项。添加ws2_32.lib和wldap32.lib，这是CURL必须依赖的。或者在代码中使用#pragma comment预编译指令，手动引入这两个lib库。")])])]),e._v(" "),s("h3",{attrs:{id:"_9-3-libcurld-lib-libcurl-lib引用方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-3-libcurld-lib-libcurl-lib引用方法"}},[e._v("#")]),e._v(" 9.3 libcurld.lib/libcurl.lib引用方法")]),e._v(" "),s("p",[e._v("将 curl-7.54.0 -> include 目录下的curl文件夹，复制过去。")]),e._v(" "),s("p",[e._v("将libcurl编译的 libcurld.dll 和 libcurld.lib 复制到debug。")]),e._v(" "),s("p",[e._v("将libcurld.dll和之前OpenSSL生成的 libeay32.dll、ssleay32.dll 各复制一份到项目文件夹下，否则会报错。")]),e._v(" "),s("p",[e._v("选择 配置属性 -> C\\C++ -> 预处理器 -> 预处理器定义，添加CURL_STATICLIB。")]),e._v(" "),s("p",[e._v("属性中的 附加包含目录、附加库目录和附加依赖项就在代码中实现。")]),e._v(" "),s("h2",{attrs:{id:"十、实例代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#十、实例代码"}},[e._v("#")]),e._v(" 十、实例代码")]),e._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('#define CURL_STATICLIB                //如果是静态库方式，需要包含这句\n \n#include "curl\\curl.h"\n#include <iostream>\n#include <list>\n#include <string>\n \n#ifdef _DEBUG\n#pragma comment(lib,"libcurld.lib")\n#else\n#pragma comment(lib,"libcurl.lib")\n#endif\n \n#pragma comment ( lib, "ws2_32.lib" )\n#pragma comment ( lib, "winmm.lib" )\n#pragma comment ( lib, "wldap32.lib" )\n#pragma comment(lib, "Advapi32.lib")\n \n \nstd::wstring AsciiToUnicode(const std::string& str)\n{\n    // 预算-缓冲区中宽字节的长度  \n    int unicodeLen = MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, nullptr, 0);\n    // 给指向缓冲区的指针变量分配内存  \n    wchar_t *pUnicode = (wchar_t*)malloc(sizeof(wchar_t)*unicodeLen);\n    // 开始向缓冲区转换字节  \n    MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, pUnicode, unicodeLen);\n    std::wstring ret_str = pUnicode;\n    free(pUnicode);\n    return ret_str;\n}\n \nstd::string UnicodeToUtf8(const std::wstring& wstr)\n{\n    // 预算-缓冲区中多字节的长度  \n    int ansiiLen = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, nullptr, 0, nullptr, nullptr);\n    // 给指向缓冲区的指针变量分配内存  \n    char *pAssii = (char*)malloc(sizeof(char)*ansiiLen);\n    // 开始向缓冲区转换字节  \n    WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), -1, pAssii, ansiiLen, nullptr, nullptr);\n    std::string ret_str = pAssii;\n    free(pAssii);\n    return ret_str;\n}\n \n//ANSI转UTF8\nstd::string AsciiToUtf8(const std::string& str)\n{\n    return UnicodeToUtf8(AsciiToUnicode(str));\n}\n \n//UTF8转ANSI\nstd::string Utf8toAscii(const std::string strUTF8)\n{\n    std::string  strAnsi = "";\n    //获取转换为多字节后需要的缓冲区大小，创建多字节缓冲区\n    UINT nLen = MultiByteToWideChar(CP_UTF8, NULL, strUTF8.c_str(), -1, NULL, NULL);\n    WCHAR *wszBuffer = new WCHAR[nLen + 1];\n    nLen = MultiByteToWideChar(CP_UTF8, NULL, strUTF8.c_str(), -1, wszBuffer, nLen);\n    wszBuffer[nLen] = 0;\n    nLen = WideCharToMultiByte(936, NULL, wszBuffer, -1, NULL, NULL, NULL, NULL);\n    CHAR *szBuffer = new CHAR[nLen + 1];\n    nLen = WideCharToMultiByte(936, NULL, wszBuffer, -1, szBuffer, nLen, NULL, NULL);\n    szBuffer[nLen] = 0;\n    strAnsi = szBuffer;\n    //清理内存\n    delete[]szBuffer;\n    delete[]wszBuffer;\n    return strAnsi;\n}\n \n// reply of the requery  \nsize_t req_reply(void *ptr, size_t size, size_t nmemb, void *stream)\n{\n    if (stream == NULL || ptr == NULL || size == 0)\n        return 0;\n \n    size_t realsize = size * nmemb;\n    std::string *buffer = (std::string*)stream;\n    if (buffer != NULL)\n    {\n        buffer->append((const char *)ptr, realsize);\n    }\n    return realsize;\n    /*\n    std::string *str = (std::string*)stream;\n    (*str).append((char*)ptr, size*nmemb);\n    return size * nmemb;\n    */\n}\n \n/*\n功能：get http数据\n参数：url：请求字符串。如果请求带参数数据，直接拼凑到url后面；比如：http://127.0.0.1:8080/api/Accounts/Login?uername=admin&password=123\nlistRequestHeader：请求头数据列表。\nbResponseIsWithHeaderData：bool类型，表示响应体中是否包含应答头数据。true，包含，false，不包含。如果包含的话，应答数据中包含Content-Type，Server等信息。\nnConnectTimeout：连接超时时间，单位为秒；\nnTimeout：读写数据超时时间，单位为秒\n返回值：CURLcode\n*/\nCURLcode curl_get_req(const std::string &url, std::string &response, std::list<std::string> listRequestHeader, bool bResponseIsWithHeaderData = false, int nConnectTimeout = 10, int nTimeout = 10)\n{\n    // init curl  \n    CURL *curl = curl_easy_init();\n    // res code  \n    CURLcode res;\n    if (curl)\n    {\n        // set params  \n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); // url  \n        //curl_easy_setopt(m_curl, CURLOPT_PORT, 8089);    //port\n        curl_easy_setopt(curl, CURLOPT_POST, 0); // get reqest \n        //构建HTTP报文头\n        struct curl_slist* headers = NULL;\n        if (listRequestHeader.size() > 0)\n        {\n            std::list<std::string>::iterator iter, iterEnd;\n            iter = listRequestHeader.begin();\n            iterEnd = listRequestHeader.end();\n            for (iter; iter != iterEnd; iter++)\n            {\n                headers = curl_slist_append(headers, iter->c_str());\n            }\n            //headers = curl_slist_append(headers, "Content-Type:application/json;charset=UTF-8");\n            //headers = curl_slist_append(headers, "Content-Type:application/x-www-form-urlencoded");\n            if (headers != NULL)\n            {\n                curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);//设置http请求头信息\n            }\n        }\n        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false); // if want to use https  \n        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, false); // set peer and host verify false  \n        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);\n        curl_easy_setopt(curl, CURLOPT_READFUNCTION, NULL);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, req_reply);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&response);\n        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n        if (bResponseIsWithHeaderData)\n        {\n            curl_easy_setopt(curl, CURLOPT_HEADER, 1);//响应体中是否包含了头信息，比如Content-Type:application/json;charset=UTF-8\n        }\n        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, nConnectTimeout); // set transport and time out time  \n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, nTimeout);\n        // start request  \n        res = curl_easy_perform(curl);\n        if (headers != NULL)\n        {\n            curl_slist_free_all(headers); //free the list again\n        }\n    }\n    // release curl  \n    curl_easy_cleanup(curl);\n    return res;\n}\n \nCURLcode curl_get_req_ex(CURL *curl, const std::string &url, std::string &response, std::list<std::string> listRequestHeader, bool bResponseIsWithHeaderData = false, int nConnectTimeout = 10, int nTimeout = 10)\n{\n    // res code  \n    CURLcode res;\n    if (curl)\n    {\n        // set params \n                curl_easy_reset(curl);\n        /* enable TCP keep-alive for this transfer */\n        curl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, 1L);\n        /* keep-alive idle time to 120 seconds */\n        curl_easy_setopt(curl, CURLOPT_TCP_KEEPIDLE, 120L);\n        /* interval time between keep-alive probes: 30 seconds */\n        curl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, 30L);\n \n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); // url  \n        //curl_easy_setopt(m_curl, CURLOPT_PORT, 8089);    //port\n        curl_easy_setopt(curl, CURLOPT_POST, 0); // get reqest \n        //构建HTTP报文头\n        struct curl_slist* headers = NULL;\n        if (listRequestHeader.size() > 0)\n        {\n            std::list<std::string>::iterator iter, iterEnd;\n            iter = listRequestHeader.begin();\n            iterEnd = listRequestHeader.end();\n            for (iter; iter != iterEnd; iter++)\n            {\n                headers = curl_slist_append(headers, iter->c_str());\n            }\n            //headers = curl_slist_append(headers, "Content-Type:application/json;charset=UTF-8");\n            //headers = curl_slist_append(headers, "Content-Type:application/x-www-form-urlencoded");\n            if (headers != NULL)\n            {\n                curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);//设置http请求头信息\n            }\n        }\n        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false); // if want to use https  \n        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, false); // set peer and host verify false  \n        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);\n        curl_easy_setopt(curl, CURLOPT_READFUNCTION, NULL);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, req_reply);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&response);\n        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n        if (bResponseIsWithHeaderData)\n        {\n            curl_easy_setopt(curl, CURLOPT_HEADER, 1);//响应体中是否包含了头信息，比如Content-Type:application/json;charset=UTF-8\n        }\n        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, nConnectTimeout); // set transport and time out time  \n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, nTimeout);\n        // start request  \n        res = curl_easy_perform(curl);\n        if (headers != NULL)\n        {\n            curl_slist_free_all(headers); //free the list again\n        }\n    }\n    return res;\n}\n \n/*\n功能：post http数据\n参数：url：请求字符串，比如：http://127.0.0.1:8080/api/Accounts/Login\npostParams：请求附带的参数，比如uername=admin&password=123\nlistRequestHeader：请求头数据列表。\nbResponseIsWithHeaderData：bool类型，表示响应体中是否包含应答头数据。true，包含，false，不包含。如果包含的话，应答数据中包含Content-Type，Server等信息。\nnConnectTimeout：连接超时时间，单位为秒；\nnTimeout：读写数据超时时间，单位为秒\n返回值：CURLcode\n*/\nCURLcode curl_post_req(const std::string &url, const std::string &postParams, std::string &response, std::list<std::string> listRequestHeader, bool bResponseIsWithHeaderData = false, int nConnectTimeout = 10, int nTimeout = 10)\n{\n    // init curl  \n    CURL *curl = curl_easy_init();\n    // res code  \n    CURLcode res;\n    if (curl)\n    {\n        // set params  \n        curl_easy_setopt(curl, CURLOPT_POST, 1); // post req  \n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); // url  \n        //curl_easy_setopt(m_curl, CURLOPT_PORT, 8089);    //port\n        curl_easy_setopt(curl, CURLOPT_POST, 1); // post reqest \n        //构建HTTP报文头\n        struct curl_slist* headers = NULL;\n        if (listRequestHeader.size() > 0)\n        {\n            std::list<std::string>::iterator iter, iterEnd;\n            iter = listRequestHeader.begin();\n            iterEnd = listRequestHeader.end();\n            for (iter; iter != iterEnd; iter++)\n            {\n                headers = curl_slist_append(headers, iter->c_str());\n            }\n            //headers = curl_slist_append(headers, "Content-Type:application/json;charset=UTF-8");\n            //headers = curl_slist_append(headers, "Content-Type:application/x-www-form-urlencoded");\n            if (headers != NULL)\n            {\n                curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);//设置http请求头信息\n            }\n        }\n        else\n        {\n            headers = curl_slist_append(headers, "Content-Type:application/x-www-form-urlencoded");\n            if (headers != NULL)\n            {\n                curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);//设置http请求头信息\n            }\n        }\n        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postParams.c_str()); // params  \n        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false); // if want to use https  \n        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, false); // set peer and host verify false  \n        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1); //返回的头部中有Location(一般直接请求的url没找到)，则继续请求Location对应的数据 \n        curl_easy_setopt(curl, CURLOPT_READFUNCTION, NULL);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, req_reply);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&response);\n        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n        if (bResponseIsWithHeaderData)\n        {\n            curl_easy_setopt(curl, CURLOPT_HEADER, 1);//响应体中是否包含了头信息，比如Content-Type:application/json;charset=UTF-8\n        }\n        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, nConnectTimeout);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, nTimeout);\n        // start request  \n        res = curl_easy_perform(curl);\n        if (headers != NULL)\n        {\n            curl_slist_free_all(headers); //free the list again\n        }\n    }\n    // release curl  \n    curl_easy_cleanup(curl);\n    return res;\n}\n \nCURLcode curl_post_req_ex(CURL *curl, const std::string &url, const std::string &postParams, std::string &response, std::list<std::string> listRequestHeader, bool bResponseIsWithHeaderData = false, int nConnectTimeout = 10, int nTimeout = 10)\n{\n    // res code  \n    CURLcode res;\n    if (curl)\n    {\n        // set params\n                curl_easy_reset(curl);\n        /* enable TCP keep-alive for this transfer */\n        curl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, 1L);\n        /* keep-alive idle time to 120 seconds */\n        curl_easy_setopt(curl, CURLOPT_TCP_KEEPIDLE, 120L);\n        /* interval time between keep-alive probes: 30 seconds */\n        curl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, 30L);\n \n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); // url  \n        //curl_easy_setopt(m_curl, CURLOPT_PORT, 8089);    //port\n        curl_easy_setopt(curl, CURLOPT_POST, 1); // post reqest \n        //构建HTTP报文头\n        struct curl_slist* headers = NULL;\n        if (listRequestHeader.size() > 0)\n        {\n            std::list<std::string>::iterator iter, iterEnd;\n            iter = listRequestHeader.begin();\n            iterEnd = listRequestHeader.end();\n            for (iter; iter != iterEnd; iter++)\n            {\n                headers = curl_slist_append(headers, iter->c_str());\n            }\n            //headers = curl_slist_append(headers, "Content-Type:application/json;charset=UTF-8");\n            //headers = curl_slist_append(headers, "Content-Type:application/x-www-form-urlencoded;charset=UTF-8");\n            if (headers != NULL)\n            {\n                curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);//设置http请求头信息\n            }\n        }\n        else\n        {\n            headers = curl_slist_append(headers, "Content-Type:application/x-www-form-urlencoded");\n            if (headers != NULL)\n            {\n                curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);//设置http请求头信息\n            }\n        }\n        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postParams.c_str()); // params  \n        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, false); // if want to use https  \n        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, false); // set peer and host verify false  \n        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1); //返回的头部中有Location(一般直接请求的url没找到)，则继续请求Location对应的数据 \n        curl_easy_setopt(curl, CURLOPT_READFUNCTION, NULL);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, req_reply);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&response);\n        curl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n        if (bResponseIsWithHeaderData)\n        {\n            curl_easy_setopt(curl, CURLOPT_HEADER, 1);//响应体中是否包含了头信息，比如Content-Type:application/json;charset=UTF-8\n        }\n        curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, nConnectTimeout);\n        curl_easy_setopt(curl, CURLOPT_TIMEOUT, nTimeout);\n        // start request  \n        res = curl_easy_perform(curl);\n        if (headers != NULL)\n        {\n            curl_slist_free_all(headers); //free the list again\n        }\n    }\n    return res;\n}\n \n//实例1\n{\n    curl_global_init(CURL_GLOBAL_ALL);\n    \n    //post获取数据\n    std::string strResponse = "",strResponseAnsi = "";\n        strResponse.clear();\n    CURLcode res = curl_post_req("http://127.0.0.1:8080/api/Accounts/Login", "username=admin&password=123", strResponse);\n    if (res == CURLE_OK)\n    {\n        std::string strToken = "";\n        strResponseAnsi = Utf8toAscii(strResponse);\n    }\n \n    //get获取数据\n        strResponse.clear();\n    res = curl_get_req("http://127.0.0.1:8080/api/Accounts/Login?username=admin&password=123", strResponse);\n    if (res == CURLE_OK)\n    {\n        int jj = 0;\n    }\n \n    curl_global_cleanup();\n}\n//实例2    \n{\n    //post json数据\n    CURL * curl = curl_easy_init();\n    std::string strResponse = "", strResponseAnsi = "";\n    char szRequestUrl[256] = { 0 };\n    CURLcode res = CURLE_OK;\n    sprintf_s(szRequestUrl, "%s/api/GPS/AddOne", "http://127.0.0.1:8080");\n    std::string strPostParams = "";\n    try\n    {\n        boost::property_tree::ptree ptroot;\n        ptroot.put("deviceid", "12345678");\n        ptroot.put<unsigned int>("deviceStatus", 0);\n        ptroot.put<unsigned int>("alarmFlag", 0);\n        ptroot.put("lng", fLongitude);\n        ptroot.put("lat", fLatitude);\n        ptroot.put("speed", 0);\n        ptroot.put("direction", 0);\n        ptroot.put<int>("altitude", 10);\n        ptroot.put("gpsTime", "2018-10-10 12:00:01");\n        std::stringstream sstream;\n        boost::property_tree::write_json(sstream, ptroot);\n        strPostParams = sstream.str();\n        bSuccess = true;\n    }\n    catch (boost::property_tree::ptree_error pt)\n    {\n        pt.what();\n    }\n    if (bSuccess)\n    {\n      std::string strAuthorization = "admin---";\n        std::string strRequestHeaders = strAuthorization;\n        std::list<std::string> listRequestHeader;\n        listRequestHeader.push_back(strRequestHeaders);\n        listRequestHeader.push_back("Content-Type:application/json;charset=UTF-8");\n        res = curl_post_req_ex(curl, szRequestUrl, strPostParams, strResponse, listRequestHeader);\n        if (res == CURLE_OK)\n        {\n            bSuccess = true;\n        }\n    }\n\tcurl_easy_cleanup(curl);\n}\n')])])]),s("h2",{attrs:{id:"注意事项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[e._v("#")]),e._v(" 注意事项：")]),e._v(" "),s("h3",{attrs:{id:"_1、http模式测试-使用postman插件或模拟测试网站"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、http模式测试-使用postman插件或模拟测试网站"}},[e._v("#")]),e._v(" 1、http模式测试，使用Postman插件或模拟测试网站")]),e._v(" "),s("p",[e._v("https://www.sojson.com/httpRequest/")]),e._v(" "),s("h3",{attrs:{id:"_2、保持长连接-设置选项。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、保持长连接-设置选项。"}},[e._v("#")]),e._v(" 2、保持长连接，设置选项。")]),e._v(" "),s("div",{staticClass:"language-c++ extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("  /* enable TCP keep-alive for this transfer */\n  curl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, 1L);\n  /* keep-alive idle time to 120 seconds */\n  curl_easy_setopt(curl, CURLOPT_TCP_KEEPIDLE, 120L);\n  /* interval time between keep-alive probes: 60 seconds */\n  curl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, 60L);\n")])])]),s("h3",{attrs:{id:"_3、调用libcurl下载-然后使用netstat查看发现有大量的tcp连接保持在close-wait状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、调用libcurl下载-然后使用netstat查看发现有大量的tcp连接保持在close-wait状态"}},[e._v("#")]),e._v(" 3、调用libcurl下载，然后使用netstat查看发现有大量的TCP连接保持在CLOSE_WAIT状态")]),e._v(" "),s("p",[e._v("查看libcurl的文档说明，有这样一个选项：CURLOPT_FORBID_REUSE")]),e._v(" "),s("p",[e._v("Pass a long. Set to 1 to make the next transfer explicitly close the connection when done. Normally, libcurl keeps all connections alive when done with one transfer in case a succeeding one follows that can re-use them. This option should be used with caution and only if you understand what it does. Set to 0 to have libcurl keep the connection open for possible later re-use (default behavior)."),s("br"),e._v("\n也就是说，默认情况下libcurl完成一个任务以后，出于重用连接的考虑不会马上关闭\n如果没有新的TCP请求来重用这个连接，那么只能等到CLOSE_WAIT超时，这个时间默认在7200秒甚至更高，太多的CLOSE_WAIT连接会导致性能问题\n解决方法：\ncurl_easy_setopt(curl, CURLOPT_FORBID_REUSE, 1);\n最好再修改一下TCP参数调低CLOSE_WAIT和TIME_WAIT的超时时间")]),e._v(" "),s("h3",{attrs:{id:"_4、libcurl进行异步并发"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、libcurl进行异步并发"}},[e._v("#")]),e._v(" 4、libcurl进行异步并发")]),e._v(" "),s("p",[e._v("使用multi接口，multi接口的使用会比easy 接口稍微复杂点，毕竟multi接口是依赖easy接口的，首先粗略的讲下其使用流程：curl_multi _init初始化一个multi curl对象，为了同时进行多个curl的并发访问，我们需要初始化多个easy curl对象，使用curl_easy_setopt进行相关设置，然后调用curl_multi _add_handle把easy curl对象添加到multi curl对象中，添加完毕后执行curl_multi_perform方法进行并发的访问，访问结束后curl_multi_remove_handle移除相关easy curl对象，curl_easy_cleanup清除easy curl对象，最后curl_multi_cleanup清除multi curl对象。multi接口具体使用方法参考下面链接")]),e._v(" "),s("p",[e._v("https://blog.csdn.net/whui19890911/article/details/79320408")]),e._v(" "),s("h3",{attrs:{id:"_5、请求头、响应头多个参数设置。使用curl-slist-append函数一个个参数插入。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5、请求头、响应头多个参数设置。使用curl-slist-append函数一个个参数插入。"}},[e._v("#")]),e._v(" 5、请求头、响应头多个参数设置。使用curl_slist_append函数一个个参数插入。")]),e._v(" "),s("h2",{attrs:{id:"参考资料"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[e._v("#")]),e._v(" 参考资料：")]),e._v(" "),s("p",[e._v("libcurl官网：https://curl.haxx.se/libcurl/")]),e._v(" "),s("p",[e._v("vc编译libcurl：https://www.cnblogs.com/findumars/p/7496122.html")]),e._v(" "),s("p",[e._v("curl_errno错误码说明")]),e._v(" "),s("p",[e._v("CURLE_UNSUPPORTED_PROTOCOL (1) – 您传送给 libcurl 的网址使用了此 libcurl 不支持的协议。 可能是您没有使用的编译时选项造成了这种情况（可能是协议字符串拼写有误，或没有指定协议 libcurl 代码）。")]),e._v(" "),s("p",[e._v("CURLE_FAILED_INIT (2) – 非常早期的初始化代码失败。 可能是内部错误或问题。")]),e._v(" "),s("p",[e._v("CURLE_URL_MALFORMAT (3) – 网址格式不正确。")]),e._v(" "),s("p",[e._v("CURLE_COULDNT_RESOLVE_PROXY (5) – 无法解析代理服务器。 指定的代理服务器主机无法解析。")]),e._v(" "),s("p",[e._v("CURLE_COULDNT_RESOLVE_HOST (6) – 无法解析主机。 指定的远程主机无法解析。")]),e._v(" "),s("p",[e._v("CURLE_COULDNT_CONNECT (7) – 无法通过 connect() 连接至主机或代理服务器。")]),e._v(" "),s("p",[e._v("CURLE_FTP_WEIRD_SERVER_REPLY (8) – 在连接到 FTP 服务器后，libcurl 需要收到特定的回复。 此错误代码表示收到了不正常或不正确的回复。 指定的远程服务器可能不是正确的 FTP 服务器。")]),e._v(" "),s("p",[e._v("CURLE_REMOTE_ACCESS_DENIED (9) – 我们无法访问网址中指定的资源。 对于 FTP，如果尝试更改为远程目录，就会发生这种情况。")]),e._v(" "),s("p",[e._v("CURLE_FTP_WEIRD_PASS_REPLY (11) – 在将 FTP 密码发送到服务器后，libcurl 需要收到正确的回复。 此错误代码表示返回的是意外的代码。")]),e._v(" "),s("p",[e._v("CURLE_FTP_WEIRD_PASV_REPLY (13) – libcurl 无法从服务器端收到有用的结果，作为对 PASV 或 EPSV 命令的响应。 服务器有问题。")]),e._v(" "),s("p",[e._v("CURLE_FTP_WEIRD_227_FORMAT (14) – FTP 服务器返回 227 行作为对 PASV 命令的响应。如果 libcurl 无法解析此行，就会返回此代码。")]),e._v(" "),s("p",[e._v("CURLE_FTP_CANT_GET_HOST (15) – 在查找用于新连接的主机时出现内部错误。")]),e._v(" "),s("p",[e._v("CURLE_FTP_COULDNT_SET_TYPE (17) – 在尝试将传输模式设置为二进制或 ascii 时发生错误。")]),e._v(" "),s("p",[e._v("CURLE_PARTIAL_FILE (18) – 文件传输尺寸小于或大于预期。当服务器先报告了一个预期的传输尺寸，然后所传送的数据与先前指定尺寸不相符时，就会发生此错误。")]),e._v(" "),s("p",[e._v("CURLE_FTP_COULDNT_RETR_FILE (19) – ‘RETR’ 命令收到了不正常的回复，或完成的传输尺寸为零字节。")]),e._v(" "),s("p",[e._v("CURLE_QUOTE_ERROR (21) – 在向远程服务器发送自定义 “QUOTE” 命令时，其中一个命令返回的错误代码为 400 或更大的数字（对于 FTP），或以其他方式表明命令无法成功完成。")]),e._v(" "),s("p",[e._v("CURLE_HTTP_RETURNED_ERROR (22) – 如 果 CURLOPT_FAILONERROR 设置为 TRUE，且 HTTP 服务器返回 >= 400 的错误代码，就会返回此代码。 （此错 误代码以前又称为 CURLE_HTTP_NOT_FOUND。）")]),e._v(" "),s("p",[e._v("CURLE_WRITE_ERROR (23) – 在向本地文件写入所收到的数据时发生错误，或由写入回调 (write callback) 向 libcurl 返回了一个错误。")]),e._v(" "),s("p",[e._v("CURLE_UPLOAD_FAILED (25) – 无法开始上传。 对于 FTP，服务器通常会拒绝执行 STOR 命令。错误缓冲区通常会提供服务器对此问题的说明。 （此错误代码以前又称为 CURLE_FTP_COULDNT_STOR_FILE。）")]),e._v(" "),s("p",[e._v("CURLE_READ_ERROR (26) – 读取本地文件时遇到问题，或由读取回调 (read callback) 返回了一个错误。")]),e._v(" "),s("p",[e._v("CURLE_OUT_OF_MEMORY (27) – 内存分配请求失败。此错误比较严重，若发生此错误，则表明出现了非常严重的问题。")]),e._v(" "),s("p",[e._v("CURLE_OPERATION_TIMEDOUT (28) – 操作超时。 已达到根据相应情况指定的超时时间。 请注意： 自 Urchin 6.6.0.2 开始，超时时间可以自行更改。 要指定远程日志下载超时， 请打开 urchin.conf 文件，取消以下行的注释标记：")]),e._v(" "),s("p",[e._v("#DownloadTimeout: 30")]),e._v(" "),s("p",[e._v("CURLE_FTP_PORT_FAILED (30) – FTP PORT 命令返回错误。 在没有为 libcurl 指定适当的地址使用时，最有可能发生此问题。 请参阅 CURLOPT_FTPPORT。")]),e._v(" "),s("p",[e._v("CURLE_FTP_COULDNT_USE_REST (31) – FTP REST 命令返回错误。如果服务器正常，则应当不会发生这种情况。")]),e._v(" "),s("p",[e._v("CURLE_RANGE_ERROR (33) – 服务器不支持或不接受范围请求。")]),e._v(" "),s("p",[e._v("CURLE_HTTP_POST_ERROR (34) – 此问题比较少见，主要由内部混乱引发。")]),e._v(" "),s("p",[e._v("CURLE_SSL_CONNECT_ERROR (35) – 同时使用 SSL/TLS 时可能会发生此错误。您可以访问错误缓冲区查看相应信息，其中会对此问题进行更详细的介绍。可能是证书（文件格式、路径、许可）、密码及其他因素导致了此问题。")]),e._v(" "),s("p",[e._v("CURLE_FTP_BAD_DOWNLOAD_RESUME (36) – 尝试恢复超过文件大小限制的 FTP 连接。")]),e._v(" "),s("p",[e._v("CURLE_FILE_COULDNT_READ_FILE (37) – 无法打开 FILE:// 路径下的文件。原因很可能是文件路径无法识别现有文件。 建议您检查文件的访问权限。")]),e._v(" "),s("p",[e._v("CURLE_LDAP_CANNOT_BIND (38) – LDAP 无法绑定。LDAP 绑定操作失败。")]),e._v(" "),s("p",[e._v("CURLE_LDAP_SEARCH_FAILED (39) – LDAP 搜索无法进行。")]),e._v(" "),s("p",[e._v("CURLE_FUNCTION_NOT_FOUND (41) – 找不到函数。 找不到必要的 zlib 函数。")]),e._v(" "),s("p",[e._v("CURLE_ABORTED_BY_CALLBACK (42) – 由回调中止。 回调向 libcurl 返回了 “abort”。")]),e._v(" "),s("p",[e._v("CURLE_BAD_FUNCTION_ARGUMENT (43) – 内部错误。 使用了不正确的参数调用函数。")]),e._v(" "),s("p",[e._v("CURLE_INTERFACE_FAILED (45) – 界 面错误。 指定的外部界面无法使用。 请通过 CURLOPT_INTERFACE 设置要使用哪个界面来处理外部连接的来源 IP 地址。 （此错误代 码以前又称为 CURLE_HTTP_PORT_FAILED。）")]),e._v(" "),s("p",[e._v("CURLE_TOO_MANY_REDIRECTS (47) – 重定向过多。 进行重定向时，libcurl 达到了网页点击上限。请使用 CURLOPT_MAXREDIRS 设置上限。")]),e._v(" "),s("p",[e._v("CURLE_UNKNOWN_TELNET_OPTION (48) – 无法识别以 CURLOPT_TELNETOPTIONS 设置的选项。 请参阅相关文档。")]),e._v(" "),s("p",[e._v("CURLE_TELNET_OPTION_SYNTAX (49) – telnet 选项字符串的格式不正确。")]),e._v(" "),s("p",[e._v("CURLE_PEER_FAILED_VERIFICATION (51) – 远程服务器的 SSL 证书或 SSH md5 指纹不正确。")]),e._v(" "),s("p",[e._v("CURLE_GOT_NOTHING (52) – 服务器未返回任何数据，在相应情况下，未返回任何数据就属于出现错误。")]),e._v(" "),s("p",[e._v("CURLE_SSL_ENGINE_NOTFOUND (53) – 找不到指定的加密引擎。")]),e._v(" "),s("p",[e._v("CURLE_SSL_ENGINE_SETFAILED (54) – 无法将选定的 SSL 加密引擎设为默认选项。")]),e._v(" "),s("p",[e._v("CURLE_SEND_ERROR (55) – 无法发送网络数据。")]),e._v(" "),s("p",[e._v("CURLE_RECV_ERROR (56) – 接收网络数据失败。")]),e._v(" "),s("p",[e._v("CURLE_SSL_CERTPROBLEM (58) – 本地客户端证书有问题")]),e._v(" "),s("p",[e._v("CURLE_SSL_CIPHER (59) – 无法使用指定的密钥")]),e._v(" "),s("p",[e._v("CURLE_SSL_CACERT (60) – 无法使用已知的 CA 证书验证对等证书")]),e._v(" "),s("p",[e._v("CURLE_BAD_CONTENT_ENCODING (61) – 无法识别传输编码")]),e._v(" "),s("p",[e._v("CURLE_LDAP_INVALID_URL (62) – LDAP 网址无效")]),e._v(" "),s("p",[e._v("CURLE_FILESIZE_EXCEEDED (63) – 超过了文件大小上限")]),e._v(" "),s("p",[e._v("CURLE_USE_SSL_FAILED (64) – 请求的 FTP SSL 级别失败")]),e._v(" "),s("p",[e._v("CURLE_SEND_FAIL_REWIND (65) – 进行发送操作时，curl 必须回转数据以便重新传输，但回转操作未能成功")]),e._v(" "),s("p",[e._v("CURLE_SSL_ENGINE_INITFAILED (66) – SSL 引擎初始化失败")]),e._v(" "),s("p",[e._v("CURLE_LOGIN_DENIED (67) – 远程服务器拒绝 curl 登录（7.13.1 新增功能）")]),e._v(" "),s("p",[e._v("CURLE_TFTP_NOTFOUND (68) – 在 TFTP 服务器上找不到文件")]),e._v(" "),s("p",[e._v("CURLE_TFTP_PERM (69) – 在 TFTP 服务器上遇到权限问题")]),e._v(" "),s("p",[e._v("CURLE_REMOTE_DISK_FULL (70) – 服务器磁盘空间不足")]),e._v(" "),s("p",[e._v("CURLE_TFTP_ILLEGAL (71) – TFTP 操作非法")]),e._v(" "),s("p",[e._v("CURLE_TFTP_UNKNOWNID (72) – TFTP 传输 ID 未知")]),e._v(" "),s("p",[e._v("CURLE_REMOTE_FILE_EXISTS (73) – 文件已存在，无法覆盖")]),e._v(" "),s("p",[e._v("CURLE_TFTP_NOSUCHUSER (74) – 运行正常的 TFTP 服务器不会返回此错误")]),e._v(" "),s("p",[e._v("CURLE_CONV_FAILED (75) – 字符转换失败")]),e._v(" "),s("p",[e._v("CURLE_CONV_REQD (76) – 调用方必须注册转换回调")]),e._v(" "),s("p",[e._v("CURLE_SSL_CACERT_BADFILE (77) – 读取 SSL CA 证书时遇到问题（可能是路径错误或访问权限问题）")]),e._v(" "),s("p",[e._v("CURLE_REMOTE_FILE_NOT_FOUND (78) – 网址中引用的资源不存在")]),e._v(" "),s("p",[e._v("CURLE_SSH (79) – SSH 会话中发生无法识别的错误")]),e._v(" "),s("p",[e._v("CURLE_SSL_SHUTDOWN_FAILED (80) – 无法终止 SSL 连接")])])}),[],!1,null,null,null);t.default=n.exports}}]);