(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{500:function(s,t,a){"use strict";a.r(t);var n=a(46),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"c语言枚举"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#c语言枚举"}},[s._v("#")]),s._v(" C语言枚举")]),s._v(" "),a("p",[s._v("enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun };")]),s._v(" "),a("ol",[a("li",[s._v("枚举列表中的 Mon、Tues、Wed 这些标识符的作用范围是全局的（严格来说是 main() 函数内部），不能再定义与它们名字相同的变量。")]),s._v(" "),a("li",[s._v("Mon、Tues、Wed 等都是常量，不能对它们赋值，只能将它们的值赋给其他的变量。")]),s._v(" "),a("li",[s._v("枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可以将枚举理解为编译阶段的宏。")]),s._v(" "),a("li",[s._v("意味着，Mon、Tues、Wed 等都不是变量，它们不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里面，放到代码区，所以不能用&取得它们的地址。这就是枚举的本质。")])]),s._v(" "),a("p",[s._v("枚举类型变量需要存放的是一个整数，下面来验证一下：")]),s._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("include")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("<stdio.h>")])]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("enum")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("week")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" Mon "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" Tues"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" Wed"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" Thurs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" Fri"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" Sat"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" Sun "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v(" day "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" Mon"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"%d, %d, %d, %d, %d\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("sizeof")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("enum")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("week")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("sizeof")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("day"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("sizeof")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("Mon"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("sizeof")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("Wed"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("sizeof")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),a("p",[s._v("运行结果：\n4, 4, 4, 4, 4")]),s._v(" "),a("h2",{attrs:{id:"c-枚举"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#c-枚举"}},[s._v("#")]),s._v(" C++枚举")]),s._v(" "),a("h3",{attrs:{id:"简述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简述"}},[s._v("#")]),s._v(" 简述")]),s._v(" "),a("p",[s._v("强类型枚举（Strongly-typed enums），号称枚举类型，是C++11中的新语法，用以解决传统C++枚举类型存在的缺陷。\n传统C++中枚举常量被暴漏在外层作用域中，这样若是同一作用域下有两个不同的枚举类型，但含有相同的枚举常量也是不可的，比如：\nenum Side{Right,Left};\nenum Thing{Wrong,Right};\n这是不能一起用的。\n另外一个缺陷是传统枚举值总是被隐式转换为整形，用户无法自定义类型。C++11中的强类型枚举解决了这些问题。")]),s._v(" "),a("h3",{attrs:{id:"强类型枚举"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强类型枚举"}},[s._v("#")]),s._v(" 强类型枚举")]),s._v(" "),a("p",[s._v("强类型枚举使用enum class语法来声明，如下：")]),s._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("enum class Enumeration{\n VAL1,\n VAL2,\n VAL3=100,\n VAL4\n};\n")])])]),a("p",[s._v("这样，枚举类型是安全的，枚举值也不会被隐式转换为整数，无法和整数数值比较，比如（Enumeration：：VAL4==10会触发编译错误）。\n另外枚举类型所使用的类型默认为int类型，也可指定其他类型，比如：")]),s._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("enum calss Enum:unsigned int{VAL1,VAL2};\n")])])]),a("p",[s._v("正如前面所说，强类型枚举能解决传统枚举不同枚举类下同枚举值名的问题，使用枚举类型的枚举名时，必须指明所属范围，比如：Enum::VAL1，而单独的VAL1则不再具有意义。\n还有一点值得说明的是C++11中枚举类型的前置声明也是可行的，比如：")]),s._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("enum class Enum;\nenum class Enum:unsigned int;\n")])])]),a("h3",{attrs:{id:"项目中的强类型枚举代码片段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#项目中的强类型枚举代码片段"}},[s._v("#")]),s._v(" 项目中的强类型枚举代码片段")]),s._v(" "),a("ol",[a("li",[s._v("图像处理\nenum class Color{RED,BLUE,YELLOR,BLACK,WHITE};")]),s._v(" "),a("li",[s._v("交通灯\nenum class TrafficLight{RED,YELLOR,GREEN};\n强类型枚举值具有传统枚举的功能——命名枚举值，同时又具有类的特点——具有类域的成员和无法进行默认的类型转换。所以也称之为枚举类——enmu class\n枚举类的底层数据必须是有符号或无符号整型，比如char unsigned int unsigned long，默认为int。")]),s._v(" "),a("li",[s._v("前置声明应用")])]),s._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("enmu class Color:char;  //前置声明枚举类\nvoid Foo(Color*p);        //前置声明的使用\n//....................\nenum class Color:char{RED,GREEN,BLACK,WHITE};                       //前置声明的定义\n")])])])])}),[],!1,null,null,null);t.default=e.exports}}]);