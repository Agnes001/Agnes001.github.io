(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{458:function(t,n,a){"use strict";a.r(n);var e=a(46),s=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"转换函数-conversion-function"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#转换函数-conversion-function"}},[t._v("#")]),t._v(" 转换函数 (conversion function)")]),t._v(" "),a("p",[t._v("格式： operator type() const"),a("br"),t._v("\n说明： 要以operator开头，函数名称为需要转成的类型，不可以有参数。前面不需要写返回类型，因为c++会自动返回函数名称这个类型。\n转换函数通常后面有const，即不需要改变数据则要加const。")]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Fraction\n{\npublic:\n    Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){ }\n    operator double() const{\n        return (double)(m_numerator/m_denominator);\n    }\nprivate:\n    int m_numerator;//分子\n    int m_denominator;//分母\n};\n\nFraction f(3,5);\ndouble d = 4+f;//调用operator double() 将f转为0.6\n")])])]),a("h2",{attrs:{id:"non-explicit-one-argument-ctor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#non-explicit-one-argument-ctor"}},[t._v("#")]),t._v(" non-explicit-one-argument ctor")]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Fraction\n{\npublic:\n    Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){ }\n    Fraction operator+(const Fraction& f){\n        return Fraction(...);\n    }\nprivate:\n    int m_numerator;//分子 \n    int m_denominator;//分母\n};\n\nFraction f(3,5);\nFraction d = f+4;//调用non-explicit ctor 将4转为Fraction(4,1),然后调用operator+\n")])])]),a("ul",[a("li",[t._v("这里没有写转换函数，而是重载了+操作符。")]),t._v(" "),a("li",[t._v("重载之后的+是分数+分数，编译器处理d2 = f+4的时候，发现右边不是分数，则看4能否转换成分数。")]),t._v(" "),a("li",[t._v("因为是只需要一个实参的构造函数，因此4可以转为分数，则可以调用重载之后的+。")]),t._v(" "),a("li",[t._v("因此non-explicit-one-argument ctor可以把其他类型转换为该类型。")])]),t._v(" "),a("h3",{attrs:{id:"conversion-function-vs-non-explicit-one-argument-ctor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conversion-function-vs-non-explicit-one-argument-ctor"}},[t._v("#")]),t._v(" conversion function VS. non-explicit-one-argument ctor")]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Fraction\n{\npublic:\n    Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){ }\n    Fraction operator+(const Fraction& f){\n        return Fraction(...);\n    }\n    operator double() const{\n        return (double)(m_numerator/m_denominator);\n    }\nprivate:\n    int m_numerator;//分子 \n    int m_denominator;//分母\n};\n\nFraction f(3,5);\nFraction d = 4+f;//[Error] ambiguous\n")])])]),a("p",[t._v("如果这两个并存了，编译器就不知道该调用哪个了。（不知道把分数转为double还是把int转为分数）")]),t._v(" "),a("h3",{attrs:{id:"explicit-one-argument-ctor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#explicit-one-argument-ctor"}},[t._v("#")]),t._v(" explicit-one-argument ctor")]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Fraction\n{\npublic:\n    explicit Fraction(int num,int den=1) : m_numerator(num),m_denominator(den){ }\n    Fraction operator+(const Fraction& f){\n        return Fraction(...);\n    }\n    operator double() const{\n        return (double)(m_numerator/m_denominator);\n    }\nprivate:\n    int m_numerator;//分子 \n    int m_denominator;//分母\n};\n\nFraction f(3,5);\nFraction d = 4+f;//[Error] conversion from double to Fraction requested\n")])])]),a("ul",[a("li",[t._v("构造函数加上explicit之后，表示这个构造函数只能在构造的时候使用，不会在转换类型时使用了。")]),t._v(" "),a("li",[t._v("这个explicit关键字主要就出现在这里。")])]),t._v(" "),a("h2",{attrs:{id:"模板"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板"}},[t._v("#")]),t._v(" 模板")]),t._v(" "),a("h3",{attrs:{id:"类模板"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类模板"}},[t._v("#")]),t._v(" 类模板")]),t._v(" "),a("p",[t._v("类模板用于实现类所需数据的类型参数化。\n类模板在使用时，必须指定类型。")]),t._v(" "),a("h4",{attrs:{id:"类模板派生普通类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类模板派生普通类"}},[t._v("#")]),t._v(" 类模板派生普通类")]),t._v(" "),a("p",[t._v("子模板类派生时，需要具体化模板类，c++编译器要知道父类的数据类型具体是什么样的，因为 c++编译器要分配内存，必须知道父类所占内存大小"),a("br"),t._v("\nclass SubClass : public MyClass<int>{};")]),t._v(" "),a("h4",{attrs:{id:"类模板派生类模板"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类模板派生类模板"}},[t._v("#")]),t._v(" 类模板派生类模板")]),t._v(" "),a("p",[t._v("template"),a("class",{attrs:{T:""}},[t._v(" class SubClass : public MyClass<T>")])],1),t._v(" "),a("p",[a("strong",[t._v("应该把类模板的声明和实现写在一起")])]),t._v(" "),a("h4",{attrs:{id:"类模板中的static关键字"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类模板中的static关键字"}},[t._v("#")]),t._v(" 类模板中的static关键字")]),t._v(" "),a("ul",[a("li",[t._v("从类模板实例化的每一个模板类有自己的类模板数据成员，该模板的所有对象共享一个 static 数据成员")]),t._v(" "),a("li",[t._v("和非模板类的 static 数据成员一样，模板类的 static 数据成员也应该在文件范围 定义和初始化")]),t._v(" "),a("li",[t._v("每个模板类有自己类模板的 static 数据成员的副本")])]),t._v(" "),a("h3",{attrs:{id:"函数模板"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数模板"}},[t._v("#")]),t._v(" 函数模板")]),t._v(" "),a("ul",[a("li",[t._v("函数模板调用，将会严格匹配类型，不会进行自动类型转换；")]),t._v(" "),a("li",[t._v("普通函数调用，可以进行隐式类型转换。")]),t._v(" "),a("li",[t._v("编译器会对函数模板进行两次编译，在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。")])]),t._v(" "),a("h3",{attrs:{id:"成员模板"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#成员模板"}},[t._v("#")]),t._v(" 成员模板")]),t._v(" "),a("h4",{attrs:{id:"例1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#例1"}},[t._v("#")]),t._v(" 例1")]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("template<typename T1,typename T2>\nstruct pair{\n    ...\n    template<typename U1,typename U2>\n    pair(const pair<U1,U2>& p):first(p.first),second(p.second){}\n    ...    \n};\n\npair<Base1,Base2> p(pair<Derived1,Derived2>());\n")])])]),a("h4",{attrs:{id:"例2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#例2"}},[t._v("#")]),t._v(" 例2")]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("template<typeneme _Tp>\nclass shared_ptr:public __shared_ptr<_Tp>{\n    ...\n    template<typename _Tp1>\n    explict shared_ptr(_Tp1* __p):__shared_ptr<_Tp>(__p){}\n    ...\n};\n\nBase1* ptr = new Derived1; //up-cast\nshared_ptr<Base1> sptr(new Derived1); //模拟up-cast\n")])])]),a("h3",{attrs:{id:"模板特化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板特化"}},[t._v("#")]),t._v(" 模板特化")]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("template <class Key>\nstruct hash{};\n\ntemplate<>\nstruct hash<char>{};\ntemplate<>\nstruct hash<int>{};\ntemplate<>\nstruct hash<long>{};\n")])])]),a("h3",{attrs:{id:"模板偏特化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板偏特化"}},[t._v("#")]),t._v(" 模板偏特化")]),t._v(" "),a("h4",{attrs:{id:"个数的偏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#个数的偏"}},[t._v("#")]),t._v(" 个数的偏")]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("template <typename T, typename Alloc = ...>\nclass vector{};\n\ntemplate <typename Alloc = ...>\nclass vector<bool,Alloc>{};\n")])])]),a("h4",{attrs:{id:"范围的偏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#范围的偏"}},[t._v("#")]),t._v(" 范围的偏")]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("template <typename T>\nclass C{};\n\ntemplate <typename T>\nclass C<T*>{};\n")])])]),a("h3",{attrs:{id:"模板模板参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板模板参数"}},[t._v("#")]),t._v(" 模板模板参数")]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("template<typename T,\n            template<typename T>\n            class Container\n        >\nclass XCls{\nprivate:\n    Container<T> c;\npublic:\n    ...\n};\n\ntemplate<typename T>\nusing Lst = list<T,alloctor<T>>;\nXls<string,Lst> mylst1;\n")])])]),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("template<typename T,\n            template<typename T>\n            class SmartPtr\n        >\nclass XCls{\nprivate:\n    SmartPtr<T> c;\npublic:\n    XCls():sp(new T){}\n};\n\nXls<string,shared_ptr> p1;\nXls<double,unique_ptr> p1; //错\nXls<int,weak_ptr> p1; //错\nXls<long,auto_ptr> p1;\n")])])]),a("h3",{attrs:{id:"数量不定的参数模板-varidic-template"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数量不定的参数模板-varidic-template"}},[t._v("#")]),t._v(" 数量不定的参数模板(varidic template)")]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("void print(){\n    ...\n}\n\ntemplate<typename T,typename... Types>\nvoid print(const T& firstArg,const Types&... args){\n    cout << firstArg << endl;\n    print(args...);\n}\n")])])]),a("h2",{attrs:{id:"仿指针类-pointer-like-classes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#仿指针类-pointer-like-classes"}},[t._v("#")]),t._v(" 仿指针类 (pointer-like classes)")]),t._v(" "),a("h3",{attrs:{id:"智能指针"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#智能指针"}},[t._v("#")]),t._v(" 智能指针")]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("template<typename T>\nclass shared_ptr{\npublic:\n    T& operator*() const{\n        return *px;\n    }\n    T* operator->() const{\n        return px;\n    }\nprivate:\n    T* px;\n    long* pn;\n}\n//指向操作符具有传递作用\nshared_ptr<Foo> sp(new Foo);\nFoo f(*sp);\nsp->method();\n")])])]),a("ul",[a("li",[t._v("设计的class，像指针。智能指针，完成比指针更多的工作。一般都是包着一层普通指针。")]),t._v(" "),a("li",[t._v("指针允许的动作，这个类也需要允许操作。")]),t._v(" "),a("li",[t._v("*操作符和->操作符都需要重载。")]),t._v(" "),a("li",[t._v("这样调用sp->的时候，实际上内部重载操作符，将内部的普通指针px返回出来，然后px可以继续使用->来完成。相当于这个->符号用了两次。\n详讲：https://zhuanlan.zhihu.com/p/436290273")])]),t._v(" "),a("p",[t._v("实践：https://blog.csdn.net/albertsh/article/details/82286999")]),t._v(" "),a("h3",{attrs:{id:"迭代器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#迭代器"}},[t._v("#")]),t._v(" 迭代器")]),t._v(" "),a("p",[t._v("stl中的迭代器也是一种指针，迭代器这种智能指针不仅需要重载*  ->操作符，还需要处理++，--等符号。")]),t._v(" "),a("h2",{attrs:{id:"仿函数类-function-like-classes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#仿函数类-function-like-classes"}},[t._v("#")]),t._v(" 仿函数类 (function-like classes)")]),t._v(" "),a("p",[t._v("设计一个class，行为像一个函数，即仿函数。")]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("template<class T>\nstruct identity{\n    const T& operator()(const T& x) const{\n        return x;\n    }\n}\n")])])]),a("ul",[a("li",[t._v("即可以使用小括号来调用。")]),t._v(" "),a("li",[t._v("对小括号（）操作符进行重载。")])]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('//一元函数对象 应用举例：for_each  \nclass print{\npublic:\n    void operator()(const int& v){\n        cout << v << " "; \n    }\n};\n\nfor_each(v.begin(),v.end(), print());\n\n//二元函数对象 应用举例：transform  \nclass myplus{\npublic:\n    int operator()(int v1,int v2){\n        return v1 + v2; \n    }\n};\n\ntransform(v1.begin(), v1.end(), v2.begin(),v3.begin(), myplus());\n\n//一元谓词 应用举例：find_if  \nclass mygreater{\npublic:\n    bool operator()(const int& v){\n        return v > 2;\n    }\n};\n\nvector<int>::iterator it = find_if(v.begin(), v.end(), mygreater()); //匿名函数对象\ncout << *it << endl;\n\n//二元谓词 应用举例：sort  \nclass mycompare{\npublic:\n    bool operator()(int v1,int v2){\n        return v1 > v2; \n    }\n};\n\nsort(v.begin(), v.end(), mycompare());\n')])])]),a("h3",{attrs:{id:"内建函数对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内建函数对象"}},[t._v("#")]),t._v(" 内建函数对象")]),t._v(" "),a("p",[t._v("使用内建函数对象，需要引入头文件 #include <functional>")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),t._v("个算数类函数对象,除了 negate 是一元运算，其他都是二元运算。\n    template"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("class T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" T plus"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("//加法仿函数\n    template"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("class T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" T minute"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("//减法仿函数\n    template"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("class T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" T multiplies"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("//乘法仿函数\n    template"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("class T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" T divides"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("//除法仿函数\n    template"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("class T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" T modulus"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("//取模仿函数\n    template"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("class T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" T negate"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("//取反仿函数\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),t._v("个关系运算类函数对象,每一种都是二元运算。\n    template"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("class T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" bool equal_to"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("//等于\n    template"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("class T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" bool not_equal_to"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("//不等于\n    template"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("class T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" bool greater"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("//大于\n    template"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("class T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" bool greater_equal"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("//大于等于\n    template"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("class T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" bool less"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("//小于\n    template"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("class T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" bool less_equal"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("//小于等于\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("个逻辑运算类运算函数,not 为一元运算，其余为二元运算。\ntemplate"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("class T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" bool logical_and"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("//逻辑与\ntemplate"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("class T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" bool logical_or"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("//逻辑或\ntemplate"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("class T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" bool logical_not"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("T"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("//逻辑非\n")])])]),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//使用内建函数对象声明一个对象\nplus<int> myPlus;\ncout << myPlus(5, 3) << endl;\n//使用匿名临时对象\ncout << plus<int>()(5, 6) << endl;\n")])])]),a("h3",{attrs:{id:"函数对象适配器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数对象适配器"}},[t._v("#")]),t._v(" 函数对象适配器")]),t._v(" "),a("p",[t._v("函数对象适配器是完成一些配接工作，这些配接包括绑定(bind)，否定(negate),以及对一般函数或成员函数的修饰，使其成为函数对象")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[t._v("bind1st ：将参数绑定为函数对象的第一个参数\nbind2nd ： 将参数绑定为函数对象的第二个参数\nnot1 ： 对一元函数对象取反\nnot2 "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(":")]),t._v(" 对二元函数对象取反\nptr_fun ： 将普通函数修饰成函数对象\nmem_fun ： 修饰成员函数\nmem_fun_ref ： 修饰成员函数\n")])])]),a("p",[t._v("如果希望函数对象适配器能对我们自己编写的函数对象有效，我们需要根据我们的函数对象类型继承 STL 的父类对象。")]),t._v(" "),a("p",[t._v("二元函数继承：public binary_function<参数类型,参数类型,返回类型>\n一元函数继承：public unary_function<参数类型,返回类型>")]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('//函数适配器 bind1st bind2nd\n//现在我有这个需求 在遍历容器的时候，我希望将容器中的值全部加上 100 之后显示出来，怎么做\n哇？\nstruct myprint : public binary_function<int,int,void>{ //二元函数对象 所以需要继承binary_fucntion<参数类型,参数类型,返回值类型>\nvoid operator()(int v1 ,int v2) const{\ncout << v1 + v2 << " "; }\n};\n//我们直接给函数对象绑定参数 编译阶段就会报错\n//for_each(v.begin(), v.end(), bind2nd(myprint(),100));\n//如果我们想使用绑定适配器,需要我们自己的函数对象继承 binary_function 或者unary_function\n//根据我们函数对象是一元函数对象 还是二元函数对象\nfor_each(v.begin(), v.end(), bind2nd(myprint(), 100));\n\n//总结： bind1st 和 bind2nd 区别?\n//bind1st ： 将参数绑定为函数对象的第一个参数\n//bind2nd ： 将参数绑定为函数对象的第二个参数\n//bind1st bind2nd 将二元函数对象转为一元函数对象\n\nvector<int>::iterator it = find_if(v.begin(), v.end(),\nnot1(bind2nd(less_equal<int>(), 2)));\ncout << "it:" << *it << endl;\nsort(v.begin(),v.end(),not2(greater<int>()));\nfor_each(v.begin(), v.end(), myprint02());\ncout << endl;\n//not1 对一元函数对象取反\n//not2 对二元函数对象取反\n\n\n//如何给一个普通函数使用绑定适配器(bind1st bind2nd)绑定一个参数？(拓展)\n//ptr_fun\nvoid myprint04(int v1,int v2){\ncout << v1 + v2 << " "; }\n\n//1 将普通函数适配成函数对象\n//2 然后通过绑定器绑定参数\nfor_each(v.begin(), v.end(), bind2nd(ptr_fun(myprint04),100));\ncout << endl;\n//总结: ptr_fun 将普通函数转变为函数对象\n\n\n//mem_fun mem_fun_ref\n//如果我们容器中存储的是对象或者对象指针，如果能指定某个成员函数处理成员数据。\nclass student{\npublic:\n    student(string name, int age) :name(name), age(age){}\n    void print(){\n        cout << "name:" << name << " age:" << age << endl;;\n    }\n    int age;\n    string name;\n};\nvoid test05(){\n//mem_fun : 如果存储的是对象指针，需要使用 mem_fun\nvector<student*> v;\nstudent* s1 = new student("zhaosi",10);\nstudent* s2 = new student("liuneng", 20);\nstudent* s3 = new student("shenyang", 30);\nstudent* s4 = new student("xiaobao", 40);\nv.push_back(s1);\nv.push_back(s2);\nv.push_back(s3);\nv.push_back(s4);\nfor_each(v.begin(), v.end(), mem_fun(&student::print));\ncout << "-----------------------------" << endl;\n//mem_fun_ref : 如果存储的是对象，需要使用 mem_fun_ref\nvector<student> v2;\nv2.push_back(student("zhaosi",50));\nv2.push_back(student("liuneng", 60));\nv2.push_back(student("shenyang", 70));\nv2.push_back(student("xiaobao", 80));\nfor_each(v2.begin(), v2.end(), mem_fun_ref(&student::print));\n')])])])])}),[],!1,null,null,null);n.default=s.exports}}]);