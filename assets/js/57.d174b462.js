(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{441:function(t,e,a){"use strict";a.r(e);var s=a(46),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("复合关系（composition）\nrb-tree -> set/map/multisey/multimap\nhashtable -> hash_set/hash_map/hash_multiset/hash_multimap\ndeque -> stack/queue\nvector -> heap/priority_queue")]),t._v(" "),a("h2",{attrs:{id:"_1-list"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-list"}},[t._v("#")]),t._v(" 1.list")]),t._v(" "),a("div",{staticClass:"language-c++ extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("list<Foo>::iterator ite;\n(*ite).method(); //reference operator*(){return (*node).data;}\nite->method(); //pointer operator->(){return &(operator*());}\n//上面的代码等同于 (*ite).method();\n// &(*ite)->method();\n")])])]),a("h2",{attrs:{id:"_2-traits"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-traits"}},[t._v("#")]),t._v(" 2.traits")]),t._v(" "),a("p",[t._v("特性、特征、特质\niterator traits用以分离 class iterators 和 non-class iterators\ntraits机必须有能力辨别它所获得的iterator是(1)class iterator T 或是(2)native pointer to T.利用partial specialization(偏特化)可达到目标。\nnon class(template) iterators 亦即natice pointer,无法定义associated types,但它的associated types 其实很直观。")]),t._v(" "),a("h2",{attrs:{id:"_3-queue和stack均使用deque做底层结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-queue和stack均使用deque做底层结构"}},[t._v("#")]),t._v(" 3.queue和stack均使用deque做底层结构")]),t._v(" "),a("p",[t._v("stack和queue都不允许遍历，也不提供iterator。\n只允许从头端或者尾端拿数据")])])}),[],!1,null,null,null);e.default=r.exports}}]);